*&---------------------------------------------------------------------*
*& Include ZRE_A2R_VALID_TASKLIST_F01
*&---------------------------------------------------------------------*

*======================================================================*
* Local event handler for SALV
*======================================================================*
CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      on_user_command FOR EVENT added_function OF cl_salv_events_table
        IMPORTING e_salv_function.
ENDCLASS.

CLASS lcl_event_handler IMPLEMENTATION.
  METHOD on_user_command.
    CASE e_salv_function.
      WHEN gc_func_char.
        PERFORM toggle_characteristics.
      WHEN gc_func_ltxt.
        PERFORM toggle_longtext.
      WHEN OTHERS.
    ENDCASE.
  ENDMETHOD.
ENDCLASS.

*======================================================================*
* Selection validation / dynpro
*======================================================================*
FORM validate_selection.

  IF p_ftl IS INITIAL AND p_etl IS INITIAL AND p_gtl IS INITIAL.
    MESSAGE e398(00) WITH 'Select at least one Task List Type'.
  ENDIF.

  IF so_keydt[] IS INITIAL OR lines( so_keydt[] ) <> 1.
    MESSAGE e398(00) WITH 'Key date must be a single value'.
  ENDIF.

ENDFORM.

FORM adjust_dynpro.
  "No complex dynamic behavior required for now.
ENDFORM.

*======================================================================*
* CI derivation from PLMK-STEUERKZ
*======================================================================*
FORM derive_ci_fields
  USING    iv_steuerkz TYPE plmk-steuerkz
  CHANGING cs_disp     TYPE ty_task_disp.

  DATA(lv_len) = strlen( iv_steuerkz ).

  IF lv_len >= 1.  cs_disp-ci_quant         = iv_steuerkz+0(1).  ENDIF.
  IF lv_len >= 2.  cs_disp-ci_meas_required = iv_steuerkz+1(1).  ENDIF.
  IF lv_len >= 3.  cs_disp-ci_attr_ref      = iv_steuerkz+2(1).  ENDIF.
  IF lv_len >= 4.  cs_disp-ci_ulim_ind      = iv_steuerkz+3(1).  ENDIF.
  IF lv_len >= 5.  cs_disp-ci_llim_ind      = iv_steuerkz+4(1).  ENDIF.
  IF lv_len >= 6.  cs_disp-ci_chk_tgt       = iv_steuerkz+5(1).  ENDIF.
  IF lv_len >= 7.  cs_disp-ci_scope         = iv_steuerkz+6(1).  ENDIF.
  IF lv_len >= 8.  cs_disp-ci_single_res    = iv_steuerkz+7(1).  ENDIF.
  IF lv_len >= 9.  cs_disp-ci_samp_req      = iv_steuerkz+8(1).  ENDIF.
  IF lv_len >= 10. cs_disp-ci_recording     = iv_steuerkz+9(1).  ENDIF.
  IF lv_len >= 11. cs_disp-ci_doc_req       = iv_steuerkz+10(1). ENDIF.
  IF lv_len >= 12. cs_disp-ci_category      = iv_steuerkz+11(1). ENDIF.

ENDFORM.

*======================================================================*
* Data selection – build GT_BASE
*======================================================================*
FORM get_data.

  CLEAR gt_base.
  REFRESH gt_base.

  DATA: lv_keydt TYPE plko-datuv.

  READ TABLE so_keydt INDEX 1 INTO DATA(ls_key).
  IF sy-subrc = 0.
    lv_keydt = ls_key-low.
  ENDIF.

  "Main join PLKO + PLPO + PLMK
  SELECT
    plko~plnty,
    plko~plnnr,
    plko~plnal,
    plko~datuv,
    plko~werks,
    plko~ktext,
    plko~verwe,
    plko~vagrp,
    plko~statu,
    plko~anlzu,
    plko~strat,
    plko~istru,
    plko~adpsp,
    plko~slwbez,
    plko~loekz,
    plko~andat,
    plko~annam,
    plko~aedat,
    plko~aenam,

    plpo~vornr,
    plpo~ltxa1,
    plpo~steus,
    plpo~arbpl,
    plpo~ktsch,
    plpo~arbei,
    plpo~arbeh,
    plpo~dauno,
    plpo~daune,
    plpo~kalid,
    plpo~execution_stage,
    plpo~anlzu,
    plpo~istru,
    plpo~larnt,
    plpo~ebeln,
    plpo~ebelp,
    plpo~lifnr,
    plpo~preis,
    plpo~waers,
    plpo~sakto,
    plpo~ekorg,
    plpo~ekgrp,
    plpo~txtsp,
    plpo~loekz,

    plmk~merknr,
    plmk~verwmerkm,
    plmk~kurztext,
    plmk~ltextkz,
    plmk~toleranzun,
    plmk~toleranzob,
    plmk~pruefeinh,
    plmk~stichprver,
    plmk~methode,
    plmk~katalgart1,
    plmk~auswmenge1,
    plmk~steuerkz,
    plmk~loekz
  FROM plko
    INNER JOIN plpo
      ON plko~plnty = plpo~plnty
     AND plko~plnnr = plpo~plnnr
     AND plko~plnal = plpo~plnal
    LEFT OUTER JOIN plmk
      ON plpo~plnty = plmk~plnty
     AND plpo~plnnr = plmk~plnnr
     AND plpo~plnkn = plmk~plnkn
  INTO TABLE @DATA(lt_raw)
  WHERE plko~datuv <= @lv_keydt
    AND plko~plnnr IN @so_plnnr
    AND plko~plnal IN @so_plnal
    AND plko~ktext IN @so_ktext
    AND plko~werks IN @so_werks
    AND plko~verwe IN @so_verwe
    AND plko~vagrp IN @so_vagrp
    AND plko~statu IN @so_stath
    AND plko~anlzu IN @so_anlzh
    AND plko~strat IN @so_strat
    AND plko~istru IN @so_istrh
    AND plko~adpsp IN @so_adpsp
    AND plko~slwbez IN @so_slwbe
    AND plko~loekz IN @so_loekh
    AND plko~andat IN @so_andat
    AND plko~annam IN @so_annam
    AND plko~aedat IN @so_aedat
    AND plko~aenam IN @so_aenam

    AND plpo~vornr IN @so_vornr
    AND plpo~ltxa1 IN @so_otext
    AND plpo~arbpl IN @so_arbpo
    AND plpo~steus IN @so_steus
    AND plpo~execution_stage IN @so_exsta
    AND plpo~anlzu IN @so_anlzo
    AND plpo~loekz IN @so_loeko
    AND plpo~ebeln IN @so_ebeln
    AND plpo~ebelp IN @so_ebelp
    AND plpo~lifnr IN @so_lifnr
    AND ( @p_opltx IS INITIAL OR plpo~txtsp <> space )

    AND ( plmk~merknr      IN @so_merkn OR plmk~merknr      IS NULL )
    AND ( plmk~verwmerkm   IN @so_mic   OR plmk~verwmerkm   IS NULL )
    AND ( plmk~kurztext    IN @so_cktxt OR plmk~kurztext    IS NULL )
    AND ( plmk~ltextkz     IN @so_ltxtk OR plmk~ltextkz     IS NULL )
    AND ( plmk~toleranzun  IN @so_tolun OR plmk~toleranzun  IS NULL )
    AND ( plmk~toleranzob  IN @so_tolob OR plmk~toleranzob  IS NULL )
    AND ( plmk~pruefeinh   IN @so_pruef OR plmk~pruefeinh   IS NULL )
    AND ( plmk~stichprver  IN @so_sproc OR plmk~stichprver  IS NULL )
    AND ( plmk~methode     IN @so_meth  OR plmk~methode     IS NULL )
    AND ( plmk~katalgart1  IN @so_kat1  OR plmk~katalgart1  IS NULL )
    AND ( plmk~auswmenge1  IN @so_ausw1 OR plmk~auswmenge1  IS NULL )
    AND ( plmk~loekz       IN @so_loekc OR plmk~loekz       IS NULL ).

  IF lt_raw IS INITIAL.
    EXIT.
  ENDIF.

  " Assign Functional Location / Equipment from TAPL / EAPL
  DATA: lt_tapl TYPE STANDARD TABLE OF tapl,
        lt_eapl TYPE STANDARD TABLE OF eapl.

  SELECT tplnr, plnty, plnnr, plnal
    FROM tapl
    INTO TABLE @lt_tapl
    FOR ALL ENTRIES IN @lt_raw
    WHERE plnty = @lt_raw-plnty
      AND plnnr = @lt_raw-plnnr
      AND plnal = @lt_raw-plnal
      AND tplnr IN @so_tplnr.

  SELECT equnr, plnty, plnnr, plnal
    FROM eapl
    INTO TABLE @lt_eapl
    FOR ALL ENTRIES IN @lt_raw
    WHERE plnty = @lt_raw-plnty
      AND plnnr = @lt_raw-plnnr
      AND plnal = @lt_raw-plnal
      AND equnr IN @so_equnr.

  SORT lt_tapl BY plnty plnnr plnal.
  SORT lt_eapl BY plnty plnnr plnal.

  CLEAR gt_base.
  LOOP AT lt_raw ASSIGNING FIELD-SYMBOL(<ls_raw>).

    CLEAR gs_base.
    MOVE-CORRESPONDING <ls_raw> TO gs_base.

    "Task list type filter (adjust PLNTY codes if needed)
    IF p_ftl = space AND <ls_raw>-plnty = 'A'.
      CONTINUE.
    ENDIF.
    IF p_etl = space AND <ls_raw>-plnty = 'E'.
      CONTINUE.
    ENDIF.
    IF p_gtl = space AND <ls_raw>-plnty = 'G'.
      CONTINUE.
    ENDIF.

    READ TABLE lt_tapl INTO DATA(ls_tapl)
         WITH KEY plnty = <ls_raw>-plnty
                  plnnr = <ls_raw>-plnnr
                  plnal = <ls_raw>-plnal
         BINARY SEARCH.
    IF sy-subrc = 0.
      gs_base-tplnr = ls_tapl-tplnr.
    ENDIF.

    READ TABLE lt_eapl INTO DATA(ls_eapl)
         WITH KEY plnty = <ls_raw>-plnty
                  plnnr = <ls_raw>-plnnr
                  plnal = <ls_raw>-plnal
         BINARY SEARCH.
    IF sy-subrc = 0.
      gs_base-equnr = ls_eapl-equnr.
    ENDIF.

    APPEND gs_base TO gt_base.

  ENDLOOP.

ENDFORM.

*======================================================================*
* Build display – operations only (compact)
*======================================================================*
FORM build_display_initial.

  CLEAR gt_display.
  REFRESH gt_display.

  DATA: lt_sorted TYPE STANDARD TABLE OF ty_task_base.
  lt_sorted = gt_base.

  SORT lt_sorted BY plnty plnnr plnal vornr merknr.

  DATA: lv_last_key TYPE string.

  LOOP AT lt_sorted INTO gs_base.

    DATA(lv_key) = |{ gs_base-plnty }-{ gs_base-plnnr }-{ gs_base-plnal }-{ gs_base-vornr }|.

    IF lv_key = lv_last_key.
      CONTINUE. " only first char per operation in compact view
    ENDIF.
    lv_last_key = lv_key.

    CLEAR gs_display.
    MOVE-CORRESPONDING gs_base TO gs_display.
    gs_display-row_kind = 'O'.

    PERFORM derive_ci_fields
      USING    gs_base-steuerkz
      CHANGING gs_display.

    APPEND gs_display TO gt_display.

  ENDLOOP.

  gv_show_char = gc_false.

ENDFORM.

*======================================================================*
* Build display – operations + characteristics
*======================================================================*
FORM build_display_with_char.

  CLEAR gt_display.
  REFRESH gt_display.

  DATA: lt_sorted TYPE STANDARD TABLE OF ty_task_base.
  lt_sorted = gt_base.

  SORT lt_sorted BY plnty plnnr plnal vornr merknr.

  DATA: lv_key TYPE string.

  LOOP AT lt_sorted INTO gs_base.

    DATA(lv_opkey) = |{ gs_base-plnty }-{ gs_base-plnnr }-{ gs_base-plnal }-{ gs_base-vornr }|.

    IF lv_opkey <> lv_key.
      lv_key = lv_opkey.

      CLEAR gs_display.
      MOVE-CORRESPONDING gs_base TO gs_display.
      gs_display-row_kind = 'O'.

      PERFORM derive_ci_fields
        USING    gs_base-steuerkz
        CHANGING gs_display.

      APPEND gs_display TO gt_display.
    ENDIF.

    IF gs_base-merknr IS NOT INITIAL.
      CLEAR gs_display.
      MOVE-CORRESPONDING gs_base TO gs_display.
      gs_display-row_kind = 'C'.

      PERFORM derive_ci_fields
        USING    gs_base-steuerkz
        CHANGING gs_display.

      APPEND gs_display TO gt_display.
    ENDIF.

  ENDLOOP.

  gv_show_char = gc_true.

ENDFORM.

*======================================================================*
* Long text helpers
*======================================================================*
FORM read_op_longtext
  USING    is_disp TYPE ty_task_disp
  CHANGING ct_disp TYPE STANDARD TABLE.

  CLEAR gt_tline.
  REFRESH gt_tline.

  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      id       = 'ILOP'
      language = sy-langu
      name     = |{ is_disp-plnty }{ is_disp-plnnr }{ is_disp-plnal }{ is_disp-vornr }|
      object   = 'PLPO'
    TABLES
      lines    = gt_tline
    EXCEPTIONS
      OTHERS   = 4.

  LOOP AT gt_tline INTO gs_tline.
    CLEAR gs_display.
    MOVE-CORRESPONDING is_disp TO gs_display.
    gs_display-row_kind = 'L'.
    gs_display-tdline   = gs_tline-tdline.
    gs_display-tdformat = gs_tline-tdformat.
    APPEND gs_display TO ct_disp.
  ENDLOOP.

ENDFORM.

FORM read_char_longtext
  USING    is_disp TYPE ty_task_disp
  CHANGING ct_disp TYPE STANDARD TABLE.

  CLEAR gt_tline.
  REFRESH gt_tline.

  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      id       = 'QL'
      language = sy-langu
      name     = |{ is_disp-plnty }{ is_disp-plnnr }{ is_disp-plnal }{ is_disp-vornr }{ is_disp-merknr }|
      object   = 'PLMK'
    TABLES
      lines    = gt_tline
    EXCEPTIONS
      OTHERS   = 4.

  LOOP AT gt_tline INTO gs_tline.
    CLEAR gs_display.
    MOVE-CORRESPONDING is_disp TO gs_display.
    gs_display-row_kind = 'L'.
    gs_display-tdline   = gs_tline-tdline.
    gs_display-tdformat = gs_tline-tdformat.
    APPEND gs_display TO ct_disp.
  ENDLOOP.

ENDFORM.

FORM add_longtext_for_ops.

  DATA: lt_result TYPE STANDARD TABLE OF ty_task_disp.

  CLEAR lt_result.

  LOOP AT gt_display INTO gs_display.
    APPEND gs_display TO lt_result.

    IF gs_display-row_kind = 'O'
       AND gs_display-txtsp_op IS NOT INITIAL.

      PERFORM read_op_longtext
        USING    gs_display
        CHANGING lt_result.

    ENDIF.

  ENDLOOP.

  gt_display = lt_result.
  gv_show_ltxt = gc_true.

ENDFORM.

FORM add_longtext_for_chars.

  DATA: lt_result TYPE STANDARD TABLE OF ty_task_disp.

  CLEAR lt_result.

  LOOP AT gt_display INTO gs_display.
    APPEND gs_display TO lt_result.

    IF gs_display-row_kind = 'C'
       AND gs_display-ltextkz = 'X'.

      PERFORM read_char_longtext
        USING    gs_display
        CHANGING lt_result.

    ENDIF.

  ENDLOOP.

  gt_display = lt_result.
  gv_show_ltxt = gc_true.

ENDFORM.

*======================================================================*
* Toggle handlers
*======================================================================*
FORM toggle_characteristics.

  "If long text is shown, FDS says Char button is disabled – here we just ignore
  IF gv_show_ltxt = gc_true.
    RETURN.
  ENDIF.

  IF gv_show_char = gc_true.
    PERFORM build_display_initial.
  ELSE.
    PERFORM build_display_with_char.
  ENDIF.

  PERFORM refresh_display.

ENDFORM.

FORM toggle_longtext.

  IF gv_show_ltxt = gc_true.
    "turn off long text
    gv_show_ltxt = gc_false.
    IF gv_show_char = gc_true.
      PERFORM build_display_with_char.
    ELSE.
      PERFORM build_display_initial.
    ENDIF.
  ELSE.
    "turn on long text
    IF gv_show_char = gc_true.
      PERFORM build_display_with_char.
      PERFORM add_longtext_for_chars.
    ELSE.
      PERFORM build_display_initial.
      PERFORM add_longtext_for_ops.
    ENDIF.
  ENDIF.

  PERFORM refresh_display.

ENDFORM.

*======================================================================*
* SALV setup
*======================================================================*
FORM display_alv.

  TRY.
      cl_salv_table=>factory(
        IMPORTING
          r_salv_table = lo_alv
        CHANGING
          t_table      = gt_display ).
    CATCH cx_salv_msg.
      MESSAGE e398(00) WITH 'Error creating ALV'.
  ENDTRY.

  PERFORM configure_salv.

  lo_alv->display( ).

ENDFORM.

FORM configure_salv.

  lo_columns = lo_alv->get_columns( ).

  TRY.
      lo_column ?= lo_columns->get_column( 'ROW_KIND' ).
      lo_column->set_technical( abap_true ).
    CATCH cx_salv_not_found.
  ENDTRY.

  lo_funcs = lo_alv->get_functions( ).
  lo_funcs->set_all( abap_true ).

  "Add custom buttons
  lo_funcs->add_function(
    name      = gc_func_char
    text      = 'Characteristics'
    tooltip   = 'Show/Hide Characteristics'
    position  = if_salv_c_function_position=>right_of_salv_functions ).

  lo_funcs->add_function(
    name      = gc_func_ltxt
    text      = 'Long Text'
    tooltip   = 'Show/Hide Long Text'
    position  = if_salv_c_function_position=>right_of_salv_functions ).

  lo_layout = lo_alv->get_layout( ).
  ls_layout_key-report = sy-repid.
  lo_layout->set_key( ls_layout_key ).
  lo_layout->set_save_restriction( if_salv_c_layout=>restrict_none ).

  lo_disp = lo_alv->get_display_settings( ).
  lo_disp->set_striped_pattern( abap_true ).
  lo_disp->set_list_header( 'Maintenance Task List Report' ).

  lo_sel = lo_alv->get_selections( ).
  lo_sel->set_selection_mode( if_salv_c_selection_mode=>row_column ).

  lo_events = lo_alv->get_event( ).
  SET HANDLER lcl_event_handler=>on_user_command FOR lo_events.

ENDFORM.

FORM refresh_display.
  IF lo_alv IS BOUND.
    lo_alv->refresh( ).
  ENDIF.
ENDFORM.