*&---------------------------------------------------------------------*
*& Include ZRE_A2R_VALID_TASKLIST_F01
*&---------------------------------------------------------------------*

*======================================================================*
* SALV EVENT HANDLER – custom buttons (Show/Hide Char, Long Text)
*======================================================================*
CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS:
      on_user_command FOR EVENT added_function OF cl_salv_events_table
        IMPORTING e_salv_function.
ENDCLASS.

CLASS lcl_event_handler IMPLEMENTATION.
  METHOD on_user_command.
    CASE e_salv_function.
      WHEN gc_func_char.
        PERFORM toggle_characteristics.
      WHEN gc_func_ltxt.
        PERFORM toggle_longtext.
      WHEN OTHERS.
    ENDCASE.
  ENDMETHOD.
ENDCLASS.

*======================================================================*
* SELECTION VALIDATION (FDS rules)
*======================================================================*
FORM validate_selection.

  " At least one Task List Type must be selected
  IF p_ftl IS INITIAL AND p_etl IS INITIAL AND p_gtl IS INITIAL.
    MESSAGE e398(00) WITH 'Select at least one Task List Type'.
  ENDIF.

  " Key Date must be single value EQ, Include
  IF lines( so_keydt[] ) <> 1
     OR so_keydt-low IS INITIAL
     OR so_keydt-sign <> 'I'
     OR so_keydt-option <> 'EQ'.
    MESSAGE e398(00) WITH 'Key date must be a single value (EQ, include)'.
  ENDIF.

ENDFORM.

*======================================================================*
* CI FLAGS FROM STEUERKZ
*======================================================================*
FORM derive_ci_fields
  USING    iv_steuerkz TYPE plmk-steuerkz
  CHANGING cs_disp     TYPE ty_task_disp.

  DATA(lv_len) = strlen( iv_steuerkz ).

  IF lv_len >= 1.  cs_disp-ci_quant         = iv_steuerkz+0(1).  ENDIF.
  IF lv_len >= 2.  cs_disp-ci_meas_required = iv_steuerkz+1(1).  ENDIF.
  IF lv_len >= 3.  cs_disp-ci_attr_ref      = iv_steuerkz+2(1).  ENDIF.
  IF lv_len >= 4.  cs_disp-ci_ulim_ind      = iv_steuerkz+3(1).  ENDIF.
  IF lv_len >= 5.  cs_disp-ci_llim_ind      = iv_steuerkz+4(1).  ENDIF.
  IF lv_len >= 6.  cs_disp-ci_chk_tgt       = iv_steuerkz+5(1).  ENDIF.
  IF lv_len >= 7.  cs_disp-ci_scope         = iv_steuerkz+6(1).  ENDIF.
  IF lv_len >= 8.  cs_disp-ci_single_res    = iv_steuerkz+7(1).  ENDIF.
  IF lv_len >= 9.  cs_disp-ci_samp_req      = iv_steuerkz+8(1).  ENDIF.
  IF lv_len >= 10. cs_disp-ci_recording     = iv_steuerkz+9(1).  ENDIF.
  IF lv_len >= 11. cs_disp-ci_doc_req       = iv_steuerkz+10(1). ENDIF.
  IF lv_len >= 12. cs_disp-ci_category      = iv_steuerkz+11(1). ENDIF.

ENDFORM.

*======================================================================*
* MAIN DATA SELECTION – fills GT_BASE from PLKO/PLPO/PLMK/TAPL/EAPL/CRHD
*======================================================================*
FORM get_data.

  CLEAR  gt_base.
  REFRESH gt_base.
  CLEAR  gs_base.

  " Key date (already single value from validate_selection)
  DATA: lv_keydt TYPE plko-datuv.
  READ TABLE so_keydt INDEX 1 INTO DATA(ls_keydt).
  IF sy-subrc = 0.
    lv_keydt = ls_keydt-low.
  ENDIF.

  " Tolerances – CHAR16 → FLTP
  DATA: lv_tolun TYPE plmk-toleranzun,
        lv_tolob TYPE plmk-toleranzob.

  IF so_tolun IS NOT INITIAL.
    lv_tolun = CONV plmk-toleranzun( so_tolun ).
  ENDIF.
  IF so_tolob IS NOT INITIAL.
    lv_tolob = CONV plmk-toleranzob( so_tolob ).
  ENDIF.

  " Main join selection
  SELECT
    plko~plnty,
    plko~plnnr,
    plko~plnal,
    plko~datuv,
    plko~werks,
    plko~ktext,
    plko~verwe,
    plko~vagrp,
    plko~statu       AS stat_h,
    plko~anlzu       AS anlzu_h,
    plko~strat,
    plko~istru       AS istru_h,
    plko~adpsp,
    plko~slwbez,
    plko~loekz       AS loekz_h,
    plko~andat,
    plko~annam,
    plko~aedat,
    plko~aenam,

    tapl~tplnr,
    eapl~equnr,

    plpo~vornr,
    plpo~ltxa1,
    plpo~steus,
    crhd~arbpl       AS arbpl_o,
    crhd~werks       AS werks_o,
    plpo~ktsch,
    plpo~arbei,
    plpo~arbeh,
    plpo~dauno,
    plpo~daune,
    plpo~kalid,
    plpo~execution_stage,
    plpo~anlzu       AS anlzu_o,
    plpo~istru       AS istru_o,
    plpo~larnt,
    plpo~ebeln,
    plpo~ebelp,
    plpo~lifnr,
    plpo~preis,
    plpo~waers,
    plpo~sakto,
    plpo~ekorg,
    plpo~ekgrp,
    plpo~txtsp       AS txtsp_op,
    plpo~loekz       AS loekz_o,

    plmk~merknr,
    plmk~verwmerkm,
    plmk~kurztext    AS kurzt_char,
    plmk~ltextkz,
    plmk~toleranzun,
    plmk~toleranzob,
    plmk~pruefeinh,
    plmk~stichprver,
    plmk~pmethode,
    plmk~katalgart1,
    plmk~auswmenge1,
    plmk~steuerkz,
    plmk~loekz       AS loekz_c

    INTO CORRESPONDING FIELDS OF TABLE @gt_base

    FROM plko
      INNER JOIN plpo
        ON plko~plnty = plpo~plnty
       AND plko~plnnr = plpo~plnnr
       AND plko~plnal = plpo~plnal

      LEFT OUTER JOIN plmk
        ON plpo~plnty = plmk~plnty
       AND plpo~plnnr = plmk~plnnr
       AND plpo~plnal = plmk~plnal
       AND plpo~plnkn = plmk~plnkn

      LEFT OUTER JOIN crhd
        ON crhd~objid = plpo~arbid

      LEFT OUTER JOIN tapl
        ON tapl~plnty = plko~plnty
       AND tapl~plnnr = plko~plnnr
       AND tapl~plnal = plko~plnal

      LEFT OUTER JOIN eapl
        ON eapl~plnty = plko~plnty
       AND eapl~plnnr = plko~plnnr
       AND eapl~plnal = plko~plnal

    WHERE plko~datuv <= @lv_keydt

      " Background deletion filters (FDS)
      AND plko~loekz = @space
      AND plpo~loekz = @space
      AND ( plmk~loekz = @space OR plmk~loekz IS NULL )

      " Task List Selection
      AND plko~plnnr IN @so_plnnr
      AND plko~plnal IN @so_plnal

      " Header Data
      AND plko~ktext IN @so_ktext
      AND plko~werks IN @so_werks
      AND plko~verwe IN @so_verwe
      AND plko~vagrp IN @so_vagrp
      AND plko~statu IN @so_stath
      AND plko~anlzu IN @so_anlzh
      AND plko~strat IN @so_strat
      AND plko~istru IN @so_istrh
      AND plko~adpsp IN @so_adpsp
      AND plko~slwbez IN @so_slwbe
      AND plko~andat IN @so_andat
      AND plko~annam IN @so_annam
      AND plko~aedat IN @so_aedat
      AND plko~aenam IN @so_aenam

      " Header work center (approx via CRHD)
      AND ( crhd~arbpl IN @so_arbph OR @so_arbph IS INITIAL )

      " Header assignments (TPLNR/EQUNR)
      AND ( tapl~tplnr IN @so_tplnr OR @so_tplnr IS INITIAL )
      AND ( eapl~equnr IN @so_equnr OR @so_equnr IS INITIAL )

      " Operation Data
      AND plpo~vornr IN @so_vornr
      AND plpo~uvorn IN @so_uvorn
      AND plpo~ltxa1 IN @so_otext
      AND plpo~steus IN @so_steus
      AND plpo~execution_stage IN @so_exsta
      AND plpo~anlzu IN @so_anlzo
      AND plpo~istru IN @so_istru
      AND plpo~ktsch IN @so_ktsch
      AND plpo~larnt IN @so_larnt
      AND plpo~ebeln IN @so_ebeln
      AND plpo~ebelp IN @so_ebelp
      AND plpo~lifnr IN @so_lifnr

      " Operation assignments (TPLNR/EQUNR at op-level)
      AND ( tapl~tplnr IN @so_optpl OR @so_optpl IS INITIAL )
      AND ( eapl~equnr IN @so_opequ OR @so_opequ IS INITIAL )

      " Work center, plant (operation)
      AND ( crhd~arbpl IN @so_arbpo OR @so_arbpo IS INITIAL )
      AND ( crhd~werks IN @so_werop OR @so_werop IS INITIAL )

      " Operation long-text indicator
      AND ( @p_oltin IS INITIAL OR plpo~txtsp <> @space )

      " Characteristic Data
      AND ( plmk~merknr    IN @so_merkn  OR @so_merkn  IS INITIAL OR plmk~merknr    IS NULL )
      AND ( plmk~verwmerkm IN @so_mic    OR @so_mic    IS INITIAL OR plmk~verwmerkm IS NULL )
      AND ( plmk~kurztext  IN @so_cktxt  OR @so_cktxt  IS INITIAL OR plmk~kurztext  IS NULL )
      AND ( plmk~ltextkz   IN @so_ltxtk  OR @so_ltxtk  IS INITIAL OR plmk~ltextkz   IS NULL )
      AND ( plmk~pmethode  IN @so_meth   OR @so_meth   IS INITIAL OR plmk~pmethode  IS NULL )
      AND ( plmk~stichprver IN @so_sproc OR @so_sproc  IS INITIAL OR plmk~stichprver IS NULL )

      " Tolerance parameters (single-value equality)
      AND ( @so_tolun IS INITIAL OR plmk~toleranzun = @lv_tolun )
      AND ( @so_tolob IS INITIAL OR plmk~toleranzob = @lv_tolob ).

  IF gt_base IS INITIAL.
    RETURN.
  ENDIF.

  " Filter by Task List Type (PLKO-PLNTY vs p_ftl/p_etl/p_gtl)
  DATA: lt_filtered TYPE STANDARD TABLE OF ty_task_base,
        lv_keep     TYPE abap_bool.

  LOOP AT gt_base INTO gs_base.
    lv_keep = abap_true.
    CASE gs_base-plnty.
      WHEN 'A'. " Functional Location
        IF p_ftl IS INITIAL.
          lv_keep = abap_false.
        ENDIF.
      WHEN 'E'. " Equipment
        IF p_etl IS INITIAL.
          lv_keep = abap_false.
        ENDIF.
      WHEN 'G'. " General
        IF p_gtl IS INITIAL.
          lv_keep = abap_false.
        ENDIF.
    ENDCASE.
    IF lv_keep = abap_true.
      APPEND gs_base TO lt_filtered.
    ENDIF.
  ENDLOOP.

  gt_base = lt_filtered.

  IF gt_base IS INITIAL.
    RETURN.
  ENDIF.

  " Apply free-text filters for long texts if entered
  IF so_opltx IS NOT INITIAL.
    PERFORM filter_by_op_longtext USING so_opltx.
  ENDIF.

  IF so_chltx IS NOT INITIAL.
    PERFORM filter_by_char_longtext USING so_chltx.
  ENDIF.

ENDFORM.

*======================================================================*
* LONG TEXT FILTER LOGIC
*======================================================================*
FORM filter_by_op_longtext USING iv_search TYPE zde_a2r_free_text.

  DATA: lt_keep_keys TYPE SORTED TABLE OF string
                         WITH UNIQUE KEY table_line,
        lv_key       TYPE string.

  " Distinct operations
  DATA: lt_ops TYPE SORTED TABLE OF ty_task_base
                       WITH UNIQUE KEY plnty plnnr plnal vornr.

  LOOP AT gt_base INTO gs_base.
    READ TABLE lt_ops WITH KEY
         plnty = gs_base-plnty
         plnnr = gs_base-plnnr
         plnal = gs_base-plnal
         vornr = gs_base-vornr
         TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      APPEND gs_base TO lt_ops.
    ENDIF.
  ENDLOOP.

  LOOP AT lt_ops INTO gs_base.

    CLEAR gt_tline.
    REFRESH gt_tline.

    " NOTE: Text object/id should follow FDS; adjust if different:
    CALL FUNCTION 'READ_TEXT'
      EXPORTING
        id       = 'IL'
        language = sy-langu
        name     = |{ gs_base-plnty }{ gs_base-plnnr }{ gs_base-plnal }{ gs_base-vornr }|
        object   = 'PLPO'
      TABLES
        lines    = gt_tline
      EXCEPTIONS
        OTHERS   = 4.

    DATA(lv_found) = abap_false.

    LOOP AT gt_tline INTO gs_tline.
      IF gs_tline-tdline CS iv_search.
        lv_found = abap_true.
        EXIT.
      ENDIF.
    ENDLOOP.

    IF lv_found = abap_true.
      lv_key = |{ gs_base-plnty }-{ gs_base-plnnr }-{ gs_base-plnal }-{ gs_base-vornr }|.
      INSERT lv_key INTO TABLE lt_keep_keys.
    ENDIF.

  ENDLOOP.

  IF lt_keep_keys IS INITIAL.
    CLEAR gt_base.
    RETURN.
  ENDIF.

  DATA: lt_new TYPE STANDARD TABLE OF ty_task_base.
  CLEAR lt_new.

  LOOP AT gt_base INTO gs_base.
    lv_key = |{ gs_base-plnty }-{ gs_base-plnnr }-{ gs_base-plnal }-{ gs_base-vornr }|.
    READ TABLE lt_keep_keys WITH KEY table_line = lv_key TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      APPEND gs_base TO lt_new.
    ENDIF.
  ENDLOOP.

  gt_base = lt_new.

ENDFORM.

FORM filter_by_char_longtext USING iv_search TYPE zde_a2r_free_text.

  DATA: lt_keep_keys TYPE SORTED TABLE OF string
                         WITH UNIQUE KEY table_line,
        lv_key       TYPE string.

  " Distinct characteristics (per operation)
  DATA: lt_chars TYPE SORTED TABLE OF ty_task_base
                       WITH UNIQUE KEY plnty plnnr plnal vornr merknr.

  LOOP AT gt_base INTO gs_base WHERE merknr IS NOT INITIAL.
    READ TABLE lt_chars WITH KEY
         plnty = gs_base-plnty
         plnnr = gs_base-plnnr
         plnal = gs_base-plnal
         vornr = gs_base-vornr
         merknr = gs_base-merknr
         TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      APPEND gs_base TO lt_chars.
    ENDIF.
  ENDLOOP.

  LOOP AT lt_chars INTO gs_base.

    CLEAR gt_tline.
    REFRESH gt_tline.

    " NOTE: characteristic long text object from AQ50PM ref (QSS/QM)
    DATA: lv_part_1 TYPE string,
          lv_part_2 TYPE string,
          lv_name   TYPE string.

    CONCATENATE plmk-mandt        " client
                gs_base-plnty
                gs_base-plnnr
                gs_base-plnkn      " not in type; if needed, adjust
      INTO lv_part_1.

    CONCATENATE gs_base-merknr '000'
      INTO lv_part_2.

    CONCATENATE lv_part_1 lv_part_2 INTO lv_name SEPARATED BY space.

    CALL FUNCTION 'READ_TEXT'
      EXPORTING
        client   = sy-mandt
        id       = 'QM'
        language = sy-langu
        name     = lv_name
        object   = 'QSS'
      TABLES
        lines    = gt_tline
      EXCEPTIONS
        OTHERS   = 4.

    DATA(lv_found) = abap_false.

    LOOP AT gt_tline INTO gs_tline.
      IF gs_tline-tdline CS iv_search.
        lv_found = abap_true.
        EXIT.
      ENDIF.
    ENDLOOP.

    IF lv_found = abap_true.
      lv_key = |{ gs_base-plnty }-{ gs_base-plnnr }-{ gs_base-plnal }-{ gs_base-vornr }-{ gs_base-merknr }|.
      INSERT lv_key INTO TABLE lt_keep_keys.
    ENDIF.

  ENDLOOP.

  IF lt_keep_keys IS INITIAL.
    CLEAR gt_base.
    RETURN.
  ENDIF.

  DATA: lt_new TYPE STANDARD TABLE OF ty_task_base.
  CLEAR lt_new.

  LOOP AT gt_base INTO gs_base.
    IF gs_base-merknr IS INITIAL.
      CONTINUE.
    ENDIF.
    lv_key = |{ gs_base-plnty }-{ gs_base-plnnr }-{ gs_base-plnal }-{ gs_base-vornr }-{ gs_base-merknr }|.
    READ TABLE lt_keep_keys WITH KEY table_line = lv_key TRANSPORTING NO FIELDS.
    IF sy-subrc = 0.
      APPEND gs_base TO lt_new.
    ENDIF.
  ENDLOOP.

  gt_base = lt_new.

ENDFORM.

*======================================================================*
* BUILD DISPLAY – OPERATIONS ONLY
*======================================================================*
FORM build_display_initial.

  CLEAR gt_display.
  REFRESH gt_display.

  DATA: lt_sorted TYPE STANDARD TABLE OF ty_task_base.
  lt_sorted = gt_base.

  SORT lt_sorted BY plnty plnnr plnal vornr merknr.

  DATA: lv_last_key TYPE string.

  LOOP AT lt_sorted INTO gs_base.

    DATA(lv_key) = |{ gs_base-plnty }-{ gs_base-plnnr }-{ gs_base-plnal }-{ gs_base-vornr }|.

    IF lv_key = lv_last_key.
      CONTINUE.
    ENDIF.
    lv_last_key = lv_key.

    CLEAR gs_display.
    MOVE-CORRESPONDING gs_base TO gs_display.
    gs_display-row_kind = 'O'.

    PERFORM derive_ci_fields
      USING    gs_base-steuerkz
      CHANGING gs_display.

    APPEND gs_display TO gt_display.

  ENDLOOP.

  gv_show_char = abap_false.

ENDFORM.

*======================================================================*
* BUILD DISPLAY – OPERATIONS + CHARACTERISTICS
*======================================================================*
FORM build_display_with_char.

  CLEAR gt_display.
  REFRESH gt_display.

  DATA: lt_sorted TYPE STANDARD TABLE OF ty_task_base.
  lt_sorted = gt_base.

  SORT lt_sorted BY plnty plnnr plnal vornr merknr.

  DATA: lv_key TYPE string.

  LOOP AT lt_sorted INTO gs_base.

    DATA(lv_opkey) = |{ gs_base-plnty }-{ gs_base-plnnr }-{ gs_base-plnal }-{ gs_base-vornr }|.

    " Operation row
    IF lv_opkey <> lv_key.
      lv_key = lv_opkey.
      CLEAR gs_display.
      MOVE-CORRESPONDING gs_base TO gs_display.
      gs_display-row_kind = 'O'.

      PERFORM derive_ci_fields
        USING    gs_base-steuerkz
        CHANGING gs_display.

      APPEND gs_display TO gt_display.
    ENDIF.

    " Characteristic row (if exists)
    IF gs_base-merknr IS NOT INITIAL.
      CLEAR gs_display.
      MOVE-CORRESPONDING gs_base TO gs_display.
      gs_display-row_kind = 'C'.

      PERFORM derive_ci_fields
        USING    gs_base-steuerkz
        CHANGING gs_display.

      APPEND gs_display TO gt_display.
    ENDIF.

  ENDLOOP.

  gv_show_char = abap_true.

ENDFORM.

*======================================================================*
* LONG TEXT APPEND – OPERATIONS
*======================================================================*
FORM read_op_longtext
  USING    is_disp TYPE ty_task_disp
  CHANGING ct_disp TYPE STANDARD TABLE OF ty_task_disp.

  CLEAR gt_tline.
  REFRESH gt_tline.

  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      id       = 'IL'
      language = sy-langu
      name     = |{ is_disp-plnty }{ is_disp-plnnr }{ is_disp-plnal }{ is_disp-vornr }|
      object   = 'PLPO'
    TABLES
      lines    = gt_tline
    EXCEPTIONS
      OTHERS   = 4.

  LOOP AT gt_tline INTO gs_tline.
    CLEAR gs_display.
    MOVE-CORRESPONDING is_disp TO gs_display.
    gs_display-row_kind = 'L'.
    gs_display-tdline   = gs_tline-tdline.
    gs_display-tdformat = gs_tline-tdformat.
    APPEND gs_display TO ct_disp.
  ENDLOOP.

ENDFORM.

*======================================================================*
* LONG TEXT APPEND – CHARACTERISTICS
*======================================================================*
FORM read_char_longtext
  USING    is_disp TYPE ty_task_disp
  CHANGING ct_disp TYPE STANDARD TABLE OF ty_task_disp.

  CLEAR gt_tline.
  REFRESH gt_tline.

  " As above, follow QSS/QM pattern (same as filter)
  DATA: lv_part_1 TYPE string,
        lv_part_2 TYPE string,
        lv_name   TYPE string.

  CONCATENATE sy-mandt
              is_disp-plnty
              is_disp-plnnr
              ' '
    INTO lv_part_1.

  CONCATENATE is_disp-merknr '000' INTO lv_part_2.

  CONCATENATE lv_part_1 lv_part_2 INTO lv_name SEPARATED BY space.

  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      client   = sy-mandt
      id       = 'QM'
      language = sy-langu
      name     = lv_name
      object   = 'QSS'
    TABLES
      lines    = gt_tline
    EXCEPTIONS
      OTHERS   = 4.

  LOOP AT gt_tline INTO gs_tline.
    CLEAR gs_display.
    MOVE-CORRESPONDING is_disp TO gs_display.
    gs_display-row_kind = 'L'.
    gs_display-tdline   = gs_tline-tdline.
    gs_display-tdformat = gs_tline-tdformat.
    APPEND gs_display TO ct_disp.
  ENDLOOP.

ENDFORM.

FORM add_longtext_for_ops.

  DATA: lt_result TYPE STANDARD TABLE OF ty_task_disp.

  CLEAR lt_result.

  LOOP AT gt_display INTO gs_display.
    APPEND gs_display TO lt_result.

    IF gs_display-row_kind = 'O'
       AND gs_display-txtsp_op IS NOT INITIAL.
      PERFORM read_op_longtext
        USING    gs_display
        CHANGING lt_result.
    ENDIF.

  ENDLOOP.

  gt_display   = lt_result.
  gv_show_ltxt = abap_true.

ENDFORM.

FORM add_longtext_for_chars.

  DATA: lt_result TYPE STANDARD TABLE OF ty_task_disp.

  CLEAR lt_result.

  LOOP AT gt_display INTO gs_display.
    APPEND gs_display TO lt_result.

    IF gs_display-row_kind = 'C'
       AND gs_display-ltextkz = 'X'.
      PERFORM read_char_longtext
        USING    gs_display
        CHANGING lt_result.
    ENDIF.

  ENDLOOP.

  gt_display   = lt_result.
  gv_show_ltxt = abap_true.

ENDFORM.

*======================================================================*
* TOGGLE HANDLERS (custom SALV buttons like in maintplan ref)
*======================================================================*
FORM toggle_characteristics.

  IF gv_show_char = abap_true.
    PERFORM build_display_initial.
    IF gv_show_ltxt = abap_true.
      PERFORM add_longtext_for_ops.
    ENDIF.
  ELSE.
    PERFORM build_display_with_char.
    IF gv_show_ltxt = abap_true.
      PERFORM add_longtext_for_chars.
    ENDIF.
  ENDIF.

  PERFORM refresh_display.

ENDFORM.

FORM toggle_longtext.

  IF gv_show_ltxt = abap_true.
    " Turn off long text – rebuild only rows without LT
    IF gv_show_char = abap_true.
      PERFORM build_display_with_char.
    ELSE.
      PERFORM build_display_initial.
    ENDIF.
    gv_show_ltxt = abap_false.
  ELSE.
    " Turn on long text
    IF gv_show_char = abap_true.
      PERFORM build_display_with_char.
      PERFORM add_longtext_for_chars.
    ELSE.
      PERFORM build_display_initial.
      PERFORM add_longtext_for_ops.
    ENDIF.
  ENDIF.

  PERFORM refresh_display.

ENDFORM.

*======================================================================*
* SALV DISPLAY
*======================================================================*
FORM display_alv.

  TRY.
      cl_salv_table=>factory(
        IMPORTING
          r_salv_table = lo_alv
        CHANGING
          t_table      = gt_display ).
    CATCH cx_salv_msg.
      MESSAGE e398(00) WITH 'Error creating ALV'.
  ENDTRY.

  PERFORM configure_salv.

  lo_alv->display( ).

ENDFORM.

FORM configure_salv.

  lo_columns = lo_alv->get_columns( ).

  " Hide technical columns
  TRY.
      lo_column ?= lo_columns->get_column( 'ROW_KIND' ).
      lo_column->set_technical( abap_true ).
    CATCH cx_salv_not_found.
  ENDTRY.

  " Enable standard functions
  lo_funcs = lo_alv->get_functions( ).
  lo_funcs->set_all( abap_true ).

  " Custom toggle buttons (like reference program)
  lo_funcs->add_function(
    name      = gc_func_char,
    text      = 'Characteristics',
    tooltip   = 'Show/Hide Characteristics',
    position  = if_salv_c_function_position=>right_of_salv_functions ).

  lo_funcs->add_function(
    name      = gc_func_ltxt,
    text      = 'Long Text',
    tooltip   = 'Show/Hide Long Text',
    position  = if_salv_c_function_position=>right_of_salv_functions ).

  " Layout, title, striping
  lo_layout = lo_alv->get_layout( ).
  ls_layout_key-report = sy-repid.
  lo_layout->set_key( ls_layout_key ).
  lo_layout->set_save_restriction( if_salv_c_layout=>restrict_none ).

  lo_disp = lo_alv->get_display_settings( ).
  lo_disp->set_striped_pattern( abap_true ).
  lo_disp->set_list_header( 'Task List Validation Report' ).

  lo_sel = lo_alv->get_selections( ).
  lo_sel->set_selection_mode( if_salv_c_selection_mode=>row_column ).

  lo_events = lo_alv->get_event( ).
  SET HANDLER lcl_event_handler=>on_user_command FOR lo_events.

ENDFORM.

FORM refresh_display.
  IF lo_alv IS BOUND.
    lo_alv->refresh( ).
  ENDIF.
ENDFORM.