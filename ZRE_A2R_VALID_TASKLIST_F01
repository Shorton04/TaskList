*&---------------------------------------------------------------------*
*& Include ZRE_A2R_VALID_TASKLIST_F01
*&---------------------------------------------------------------------*

*---------------------------------------------------------------------*
* Local class for SALV user command (custom buttons)
*---------------------------------------------------------------------*
CLASS lcl_event_handler DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS on_user_command
      FOR EVENT added_function OF cl_salv_events_table
      IMPORTING e_salv_function.
ENDCLASS.

CLASS lcl_event_handler IMPLEMENTATION.
  METHOD on_user_command.

    CASE e_salv_function.

      WHEN gc_func_char.
        "Toggle characteristics
        IF gv_show_char = gc_true.
          gv_show_char = gc_false.
        ELSE.
          gv_show_char = gc_true.
        ENDIF.

      WHEN gc_func_ltxt.
        "Toggle long text
        IF gv_show_ltxt = gc_true.
          gv_show_ltxt = gc_false.
        ELSE.
          gv_show_ltxt = gc_true.
        ENDIF.

      WHEN OTHERS.
        RETURN.

    ENDCASE.

    "Rebuild display and refresh ALV
    PERFORM build_display.

    IF lo_alv IS BOUND.
      lo_alv->refresh( ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.


*---------------------------------------------------------------------*
* Validate selection
*---------------------------------------------------------------------*
FORM validate_selection.

  "At least one task list type
  IF p_ftl IS INITIAL AND
     p_etl IS INITIAL AND
     p_gtl IS INITIAL.
    MESSAGE e398(00) WITH 'Select at least one Task List Type'.
  ENDIF.

  "Key date (already OBLIGATORY, but double-check)
  IF so_keydt-low IS INITIAL.
    MESSAGE e398(00) WITH 'Enter a key date'.
  ENDIF.

ENDFORM.

*---------------------------------------------------------------------*
* Derive CI flags from PLMK-STEUERKZ
*---------------------------------------------------------------------*
FORM derive_ci_fields
  USING    iv_steuerkz TYPE plmk-steuerkz
  CHANGING cs_disp     TYPE ty_task_disp.

  DATA: lv_len TYPE i.

  lv_len = strlen( iv_steuerkz ).

  IF lv_len GE 1.  cs_disp-ci_quant         = iv_steuerkz+0(1).  ENDIF.
  IF lv_len GE 2.  cs_disp-ci_meas_required = iv_steuerkz+1(1).  ENDIF.
  IF lv_len GE 3.  cs_disp-ci_attr_ref      = iv_steuerkz+2(1).  ENDIF.
  IF lv_len GE 4.  cs_disp-ci_ulim_ind      = iv_steuerkz+3(1).  ENDIF.
  IF lv_len GE 5.  cs_disp-ci_llim_ind      = iv_steuerkz+4(1).  ENDIF.
  IF lv_len GE 6.  cs_disp-ci_chk_tgt       = iv_steuerkz+5(1).  ENDIF.
  IF lv_len GE 7.  cs_disp-ci_scope         = iv_steuerkz+6(1).  ENDIF.
  IF lv_len GE 8.  cs_disp-ci_single_res    = iv_steuerkz+7(1).  ENDIF.
  IF lv_len GE 9.  cs_disp-ci_samp_req      = iv_steuerkz+8(1).  ENDIF.
  IF lv_len GE 10. cs_disp-ci_recording     = iv_steuerkz+9(1).  ENDIF.
  IF lv_len GE 11. cs_disp-ci_doc_req       = iv_steuerkz+10(1). ENDIF.
  IF lv_len GE 12. cs_disp-ci_category      = iv_steuerkz+11(1). ENDIF.

ENDFORM.

*---------------------------------------------------------------------*
* GET_DATA
*---------------------------------------------------------------------*
FORM get_data.

  DATA: lv_keydat TYPE plko-datuv,
        lv_tolun  TYPE plmk-toleranzun,
        lv_tolob  TYPE plmk-toleranzob.

  CLEAR gt_base.
  CLEAR gs_base.

  " Key date (single value)
  lv_keydat = so_keydt-low.

  " Tolerance parameters (CHAR16 -> FLTP variables)
  CLEAR: lv_tolun, lv_tolob.
  IF so_tolun IS NOT INITIAL.
    lv_tolun = so_tolun.    " implicit conv CHAR16 -> FLTP
  ENDIF.
  IF so_tolob IS NOT INITIAL.
    lv_tolob = so_tolob.
  ENDIF.

  "-------------------------------------------------------------------*
  " Core selection: PLKO – PLAS – PLPO – PLMK – TAPL – EAPL – CRHD
  " Only background filters (deletion flags + key date) are in WHERE.
  " All user selection options are applied afterwards in LOOP.
  "-------------------------------------------------------------------*
  SELECT
    plko~plnty          " header
    plko~plnnr
    plko~plnal
    plko~datuv
    plko~werks
    plko~ktext
    plko~verwe
    plko~vagrp
    plko~statu     AS stat_h
    plko~anlzu     AS anlzu_h
    plko~strat
    plko~istru     AS istru_h
    plko~adpsp
    plko~slwbez
    plko~loekz     AS loekz_h
    plko~andat
    plko~annam
    plko~aedat
    plko~aenam

    tapl~tplnr      " FLOC assignment
    eapl~equnr      " EQUIP assignment

    plpo~vornr      " operation
    plpo~ltxa1
    plpo~steus
    crhd~arbpl      AS arbpl_o
    crhd~werks      AS werks_o
    plpo~ktsch
    plpo~arbei
    plpo~arbeh
    plpo~dauno
    plpo~daune
    plpo~kalid
    plpo~execution_stage
    plpo~anlzu      AS anlzu_o
    plpo~istru      AS istru_o
    plpo~larnt
    plpo~ebeln
    plpo~ebelp
    plpo~lifnr
    plpo~preis
    plpo~waers
    plpo~sakto
    plpo~ekorg
    plpo~ekgrp
    plpo~txtsp      AS txtsp_op
    plpo~loekz      AS loekz_o

    plmk~merknr     " characteristic
    plmk~verwmerkm
    plmk~kurztext   AS kurzt_char
    plmk~ltextkz
    plmk~toleranzun
    plmk~toleranzob
    plmk~pruefeinh
    plmk~stichprver
    plmk~pmethode
    plmk~katalgart1
    plmk~auswmenge1
    plmk~steuerkz
    plmk~loekz      AS loekz_c

    INTO CORRESPONDING FIELDS OF TABLE gt_base

    FROM  plko
      INNER JOIN plas
        ON  plas~plnty = plko~plnty
        AND plas~plnnr = plko~plnnr
        AND plas~plnal = plko~plnal
        AND plas~loekz = ' '
      INNER JOIN plpo
        ON  plpo~plnty = plas~plnty
        AND plpo~plnnr = plas~plnnr
        AND plpo~plnkn = plas~plnkn
        AND plpo~zaehl = plas~zaehl
        AND plpo~loekz = ' '
      LEFT OUTER JOIN plmk
        ON  plmk~plnty = plpo~plnty
        AND plmk~plnnr = plpo~plnnr
        AND plmk~plnkn = plpo~plnkn
        AND plmk~zaehl = plpo~zaehl
        AND plmk~loekz = ' '
      LEFT OUTER JOIN tapl
        ON  tapl~plnty = plko~plnty
        AND tapl~plnnr = plko~plnnr
        AND tapl~plnal = plko~plnal
        AND tapl~loekz = ' '
      LEFT OUTER JOIN eapl
        ON  eapl~plnty = plko~plnty
        AND eapl~plnnr = plko~plnnr
        AND eapl~plnal = plko~plnal
        AND eapl~loekz = ' '
      LEFT OUTER JOIN crhd
        ON  crhd~objid = plpo~arbid

    WHERE plko~loekz = ' '        " header not deleted
      AND plko~datuv <= lv_keydat.

  "-------------------------------------------------------------------*
  " Apply all selection-screen filters in ABAP on GT_BASE
  " (no table aliases here – just structure GS_BASE)
  "-------------------------------------------------------------------*
  DATA: lt_filtered TYPE STANDARD TABLE OF ty_task_base.

  CLEAR lt_filtered.

  LOOP AT gt_base INTO gs_base.

    " Task list type via PLNTY and checkboxes
    IF gs_base-plnty = 'A' AND p_ftl IS INITIAL.
      CONTINUE.
    ENDIF.
    IF gs_base-plnty = 'B' AND p_etl IS INITIAL.
      CONTINUE.
    ENDIF.
    IF gs_base-plnty = 'E' AND p_gtl IS INITIAL.
      CONTINUE.
    ENDIF.

    " ---- Task list selection ----
    IF so_tplnr[] IS NOT INITIAL AND gs_base-tplnr NOT IN so_tplnr.
      CONTINUE.
    ENDIF.
    IF so_equnr[] IS NOT INITIAL AND gs_base-equnr NOT IN so_equnr.
      CONTINUE.
    ENDIF.
    IF so_plnnr[] IS NOT INITIAL AND gs_base-plnnr NOT IN so_plnnr.
      CONTINUE.
    ENDIF.
    IF so_plnal[] IS NOT INITIAL AND gs_base-plnal NOT IN so_plnal.
      CONTINUE.
    ENDIF.

    " ---- Header data ----
    IF so_ktext[] IS NOT INITIAL AND gs_base-ktext NOT IN so_ktext.
      CONTINUE.
    ENDIF.
    IF so_werks[] IS NOT INITIAL AND gs_base-werks NOT IN so_werks.
      CONTINUE.
    ENDIF.
    IF so_vagrp[] IS NOT INITIAL AND gs_base-vagrp NOT IN so_vagrp.
      CONTINUE.
    ENDIF.
    IF so_verwe[] IS NOT INITIAL AND gs_base-verwe NOT IN so_verwe.
      CONTINUE.
    ENDIF.
    IF so_stath[] IS NOT INITIAL AND gs_base-stat_h NOT IN so_stath.
      CONTINUE.
    ENDIF.
    IF so_anlzh[] IS NOT INITIAL AND gs_base-anlzu_h NOT IN so_anlzh.
      CONTINUE.
    ENDIF.
    IF so_strat[] IS NOT INITIAL AND gs_base-strat NOT IN so_strat.
      CONTINUE.
    ENDIF.
    IF so_istrh[] IS NOT INITIAL AND gs_base-istru_h NOT IN so_istrh.
      CONTINUE.
    ENDIF.
    IF so_adpsp[] IS NOT INITIAL AND gs_base-adpsp NOT IN so_adpsp.
      CONTINUE.
    ENDIF.
    IF so_slwbe[] IS NOT INITIAL AND gs_base-slwbez NOT IN so_slwbe.
      CONTINUE.
    ENDIF.
    IF so_andat[] IS NOT INITIAL AND gs_base-andat NOT IN so_andat.
      CONTINUE.
    ENDIF.
    IF so_annam[] IS NOT INITIAL AND gs_base-annam NOT IN so_annam.
      CONTINUE.
    ENDIF.
    IF so_aedat[] IS NOT INITIAL AND gs_base-aedat NOT IN so_aedat.
      CONTINUE.
    ENDIF.
    IF so_aenam[] IS NOT INITIAL AND gs_base-aenam NOT IN so_aenam.
      CONTINUE.
    ENDIF.

    " ---- Operation data ----
    IF so_vornr[] IS NOT INITIAL AND gs_base-vornr NOT IN so_vornr.
      CONTINUE.
    ENDIF.
    IF so_uvorn[] IS NOT INITIAL AND gs_base-vornr NOT IN so_uvorn.
      CONTINUE.
    ENDIF.
    IF so_otext[] IS NOT INITIAL AND gs_base-ltxa1 NOT IN so_otext.
      CONTINUE.
    ENDIF.
    IF so_steus[] IS NOT INITIAL AND gs_base-steus NOT IN so_steus.
      CONTINUE.
    ENDIF.
    IF so_arbpo[] IS NOT INITIAL AND gs_base-arbpl_o NOT IN so_arbpo.
      CONTINUE.
    ENDIF.
    IF so_optpl[] IS NOT INITIAL AND gs_base-tplnr NOT IN so_optpl.
      CONTINUE.
    ENDIF.
    IF so_opequ[] IS NOT INITIAL AND gs_base-equnr NOT IN so_opequ.
      CONTINUE.
    ENDIF.
    IF so_ktsch[] IS NOT INITIAL AND gs_base-ktsch NOT IN so_ktsch.
      CONTINUE.
    ENDIF.
    IF so_exsta[] IS NOT INITIAL AND gs_base-execution_stage NOT IN so_exsta.
      CONTINUE.
    ENDIF.
    IF so_anlzo[] IS NOT INITIAL AND gs_base-anlzu_o NOT IN so_anlzo.
      CONTINUE.
    ENDIF.
    IF so_istru[] IS NOT INITIAL AND gs_base-istru_o NOT IN so_istru.
      CONTINUE.
    ENDIF.
    IF so_larnt[] IS NOT INITIAL AND gs_base-larnt NOT IN so_larnt.
      CONTINUE.
    ENDIF.
    IF so_ebeln[] IS NOT INITIAL AND gs_base-ebeln NOT IN so_ebeln.
      CONTINUE.
    ENDIF.
    IF so_ebelp[] IS NOT INITIAL AND gs_base-ebelp NOT IN so_ebelp.
      CONTINUE.
    ENDIF.
    IF so_lifnr[] IS NOT INITIAL AND gs_base-lifnr NOT IN so_lifnr.
      CONTINUE.
    ENDIF.

    " Operation long-text indicator
    IF p_oltin = 'X' AND gs_base-txtsp_op IS INITIAL.
      CONTINUE.
    ENDIF.

    " ---- Characteristic data ----
    IF so_merkn[] IS NOT INITIAL AND gs_base-merknr NOT IN so_merkn.
      CONTINUE.
    ENDIF.
    IF so_mic[] IS NOT INITIAL AND gs_base-verwmerkm NOT IN so_mic.
      CONTINUE.
    ENDIF.
    IF so_cktxt[] IS NOT INITIAL AND gs_base-kurzt_char NOT IN so_cktxt.
      CONTINUE.
    ENDIF.
    IF so_ltxtk[] IS NOT INITIAL AND gs_base-ltextkz NOT IN so_ltxtk.
      CONTINUE.
    ENDIF.
    IF so_meth[] IS NOT INITIAL AND gs_base-pmethode NOT IN so_meth.
      CONTINUE.
    ENDIF.
    IF so_sproc[] IS NOT INITIAL AND gs_base-stichprver NOT IN so_sproc.
      CONTINUE.
    ENDIF.

    IF so_tolun IS NOT INITIAL AND gs_base-toleranzun <> lv_tolun.
      CONTINUE.
    ENDIF.
    IF so_tolob IS NOT INITIAL AND gs_base-toleranzob <> lv_tolob.
      CONTINUE.
    ENDIF.

    " All checks passed
    APPEND gs_base TO lt_filtered.

  ENDLOOP.

  gt_base = lt_filtered.

ENDFORM.

*&---------------------------------------------------------------------*
*& Module STATUS_0100 OUTPUT
*&---------------------------------------------------------------------*
*  - Sets PF-STATUS based on gv_show_char / gv_show_ltxt
*  - Creates container + SALV on first call
*  - Applies ALV layout / column settings
*&---------------------------------------------------------------------*
MODULE status_0100 OUTPUT.

  PERFORM set_pfstatus_from_state.
  PERFORM set_title_from_state.

  "Create container + SALV only once
  IF go_container IS INITIAL.

    CREATE OBJECT go_container
      EXPORTING
        container_name = 'CC_ALV'.   "Custom Control name on Screen 0100

    "Initial build of display table
    PERFORM build_display.

    "Create SALV inside container
    cl_salv_table=>factory(
      EXPORTING
        r_container  = go_container
      IMPORTING
        r_salv_table = lo_alv
      CHANGING
        t_table      = gt_display ).

    "Basic ALV settings
    PERFORM display_alv.

  ELSE.
    "Dataset might have changed between calls
    IF lo_alv IS BOUND.
      lo_alv->refresh( ).
    ENDIF.
  ENDIF.

ENDMODULE.


*&---------------------------------------------------------------------*
*& Module USER_COMMAND_0100 INPUT
*&---------------------------------------------------------------------*
*  - Handles PF-STATUS buttons:
*      Show/Hide Characteristics
*      Show/Hide Long Text
*      Refresh / Back / Exit / Cancel
*&---------------------------------------------------------------------*
MODULE user_command_0100 INPUT.

  CASE sy-ucomm.

    WHEN gc_button_char OR gc_button_charh.
      PERFORM toggle_char.

    WHEN gc_button_ltxt OR gc_button_ltxth.
      PERFORM toggle_ltxt.

    WHEN 'REFRESH'.
      PERFORM build_display.
      IF lo_alv IS BOUND.
        lo_alv->refresh( ).
      ENDIF.

    WHEN gc_button_back OR gc_button_exit OR gc_button_cancel.
      CLEAR: gv_show_char, gv_show_ltxt.
      LEAVE TO SCREEN 0.

  ENDCASE.

ENDMODULE.


*======================================================================*
*   Helper Forms – PF-STATUS / Title / ALV configuration
*======================================================================*

*&---------------------------------------------------------------------*
*& Form set_pfstatus_from_state
*&---------------------------------------------------------------------*
*  - Chooses which PF-STATUS to use based on flags
*&---------------------------------------------------------------------*
FORM set_pfstatus_from_state.

  DATA lv_pfstatus TYPE sypfkey.

  IF gv_show_char = gc_true AND gv_show_ltxt = gc_true.
    lv_pfstatus = 'ZSALV_TL_BOTH'.
  ELSEIF gv_show_char = gc_true AND gv_show_ltxt = gc_false.
    lv_pfstatus = 'ZSALV_TL_CHAR'.
  ELSEIF gv_show_char = gc_false AND gv_show_ltxt = gc_true.
    lv_pfstatus = 'ZSALV_TL_LTXT'.
  ELSE.
    lv_pfstatus = 'ZSALV_TL_NONE'.
  ENDIF.

  SET PF-STATUS lv_pfstatus.

ENDFORM.


*&---------------------------------------------------------------------*
*& Form set_title_from_state
*&---------------------------------------------------------------------*
*  - Builds a dynamic title text depending on current state
*&---------------------------------------------------------------------*
FORM set_title_from_state.

  DATA lv_title TYPE string.

  lv_title = 'Maintenance Task List Report'.

  IF gv_show_char = gc_true.
    lv_title = lv_title && ' - Characteristics Active'.
  ENDIF.
  IF gv_show_ltxt = gc_true.
    lv_title = lv_title && ' - Long Text Active'.
  ENDIF.

  "GUI Title must exist in SE41 (e.g. TITLE_100)
  SET TITLEBAR 'TITLE_100' WITH lv_title.

ENDFORM.


*======================================================================*
*   Core logic – Build display & Long text helpers
*======================================================================*

*&---------------------------------------------------------------------*
*& Form build_display
*&---------------------------------------------------------------------*
*  - Builds GT_DISPLAY based on GT_BASE and flags:
*      gv_show_char, gv_show_ltxt
*  - One operation row for each op (ROW_KIND = 'O')
*  - Optionally:
*      - Op long text rows (ROW_KIND = 'L', OP_LTXT filled)
*      - Characteristic rows (ROW_KIND = 'C')
*      - Char long text rows (ROW_KIND = 'L', CHAR_LTXT filled)
*&---------------------------------------------------------------------*
FORM build_display.

  DATA: lv_last_plnty TYPE plko-plnty,
        lv_last_plnnr TYPE plko-plnnr,
        lv_last_plnal TYPE plko-plnal,
        lv_last_vornr TYPE plpo-vornr.

  CLEAR gt_display.
  CLEAR gs_display.

  CLEAR: lv_last_plnty, lv_last_plnnr, lv_last_plnal, lv_last_vornr.

  LOOP AT gt_base INTO gs_base.

    "---------------------------------------------------------------*
    " 1) Operation row – only when operation key changes
    "---------------------------------------------------------------*
    IF gs_base-plnty <> lv_last_plnty OR
       gs_base-plnnr <> lv_last_plnnr OR
       gs_base-plnal <> lv_last_plnal OR
       gs_base-vornr <> lv_last_vornr.

      CLEAR gs_display.
      MOVE-CORRESPONDING gs_base TO gs_display.
      gs_display-row_kind = 'O'.

      " Derive CI indicators etc. (if you have a helper FORM)
      PERFORM derive_ci_fields
        USING    gs_base-steuerkz
        CHANGING gs_display.

      APPEND gs_display TO gt_display.

      "Remember last operation key
      lv_last_plnty = gs_base-plnty.
      lv_last_plnnr = gs_base-plnnr.
      lv_last_plnal = gs_base-plnal.
      lv_last_vornr = gs_base-vornr.

      "Operation long text lines (if Show Long Text is active)
      IF gv_show_ltxt = gc_true
         AND gs_base-txtsp_op IS NOT INITIAL.
        PERFORM append_op_longtext USING gs_base.
      ENDIF.

    ENDIF.

    "---------------------------------------------------------------*
    " 2) Characteristic row + long text (if Show Characteristics)
    "---------------------------------------------------------------*
    IF gv_show_char = gc_true
       AND gs_base-merknr IS NOT INITIAL.

      "Characteristic row
      CLEAR gs_display.
      MOVE-CORRESPONDING gs_base TO gs_display.
      gs_display-row_kind = 'C'.

      PERFORM derive_ci_fields
        USING    gs_base-steuerkz
        CHANGING gs_display.

      APPEND gs_display TO gt_display.

      "Characteristic long text (if long text indicator is set)
      IF gs_base-ltextkz IS NOT INITIAL
         AND gv_show_ltxt = gc_true.
        PERFORM append_char_longtext USING gs_base.
      ENDIF.

    ENDIF.

  ENDLOOP.

ENDFORM.

*---------------------------------------------------------------------*
* Display ALV with SALV and two custom buttons
*---------------------------------------------------------------------*
FORM display_alv.

  DATA: lx_salv_msg TYPE REF TO cx_salv_msg,
        lx_salv_ex  TYPE REF TO cx_root,
        lv_title    TYPE lvc_title.

  "No data – nothing to show
  IF gt_display IS INITIAL.
    MESSAGE s398(00) WITH 'No data to display'.
    RETURN.
  ENDIF.

  TRY.

      "---------------------------------------------------------------*
      " Create SALV
      "---------------------------------------------------------------*
      cl_salv_table=>factory(
        IMPORTING
          r_salv_table = lo_alv
        CHANGING
          t_table      = gt_display ).

      "---------------------------------------------------------------*
      " Columns
      "---------------------------------------------------------------*
      lo_columns = lo_alv->get_columns( ).
      lo_columns->set_optimize( abap_true ).

      "Hide technical columns
      TRY.
          lo_column ?= lo_columns->get_column( 'ROW_KIND' ).
          lo_column->set_technical( abap_true ).
        CATCH cx_salv_not_found.
      ENDTRY.

      TRY.
          lo_column ?= lo_columns->get_column( 'TDFORMAT' ).
          lo_column->set_technical( abap_true ).
        CATCH cx_salv_not_found.
      ENDTRY.

      "---------------------------------------------------------------*
      " Display settings
      "---------------------------------------------------------------*
      lo_disp = lo_alv->get_display_settings( ).
      lo_disp->set_striped_pattern( abap_true ).

      lv_title = 'Valid Task Lists'.
      lo_disp->set_list_header( lv_title ).

      "---------------------------------------------------------------*
      " Layout
      "---------------------------------------------------------------*
      lo_layout = lo_alv->get_layout( ).
      ls_layout_key-report = sy-repid.
      lo_layout->set_key( ls_layout_key ).
      lo_layout->set_save_restriction( if_salv_c_layout=>restrict_none ).
      lo_layout->set_default( abap_true ).

      "---------------------------------------------------------------*
      " Standard functions + custom buttons
      "---------------------------------------------------------------*
      lo_funcs = lo_alv->get_functions( ).
      lo_funcs->set_all( abap_true ).

      "Custom button – Characteristics
      lo_funcs->add_function(
        name     = gc_func_char      " 'ZCHAR'
        text     = 'Characteristics'
        tooltip  = 'Show / Hide characteristics'
        position = if_salv_c_function_position=>right_of_salv_functions ).

      "Custom button – Long text
      lo_funcs->add_function(
        name     = gc_func_ltxt      " 'ZLTXT'
        text     = 'Long Text'
        tooltip  = 'Show / Hide long text'
        position = if_salv_c_function_position=>right_of_salv_functions ).

      "---------------------------------------------------------------*
      " Selections
      "---------------------------------------------------------------*
      lo_sel = lo_alv->get_selections( ).
      lo_sel->set_selection_mode( if_salv_c_selection_mode=>row_column ).

      "---------------------------------------------------------------*
      " Events – static handler (Maintplan pattern)
      "---------------------------------------------------------------*
      lo_events = lo_alv->get_event( ).
      SET HANDLER lcl_event_handler=>on_user_command FOR lo_events.

      "---------------------------------------------------------------*
      " Display ALV
      "---------------------------------------------------------------*
      lo_alv->display( ).

    CATCH cx_salv_existing INTO lx_salv_ex.
      MESSAGE lx_salv_ex->get_text( ) TYPE 'E'.

    CATCH cx_salv_wrong_call INTO lx_salv_ex.
      MESSAGE lx_salv_ex->get_text( ) TYPE 'E'.

    CATCH cx_salv_msg INTO lx_salv_msg.
      MESSAGE lx_salv_msg->get_text( ) TYPE 'E'.

  ENDTRY.

ENDFORM.

*&---------------------------------------------------------------------*
*& Form append_op_longtext
*&---------------------------------------------------------------------*
*  - Appends operation long text lines as separate rows in GT_DISPLAY
*    with ROW_KIND = 'L' and OP_LTXT filled
*&---------------------------------------------------------------------*
FORM append_op_longtext USING is_base TYPE ty_task_base.

  DATA: ls_thead TYPE thead,
        lv_name  TYPE thead-tdname.

  CLEAR gt_tline.

  "Build text name per FDS (adjust if your key is different)
  "Example: PLNTY + PLNNR (ALPHA) + PLNAL + VORNR
  lv_name = |{ is_base-plnty }{ is_base-plnnr ALPHA = OUT }{ is_base-plnal }{ is_base-vornr }|.

  CLEAR ls_thead.
  ls_thead-tdid     = 'PLPO'.     "Operation long text ID (adjust if needed)
  ls_thead-tdspras  = sy-langu.
  ls_thead-tdname   = lv_name.
  ls_thead-tdobject = 'PLPO'.    "Operation text object (adjust if needed)

  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      id       = ls_thead-tdid
      language = ls_thead-tdspras
      name     = ls_thead-tdname
      object   = ls_thead-tdobject
    TABLES
      lines    = gt_tline
    EXCEPTIONS
      OTHERS   = 4.

  IF sy-subrc <> 0 OR gt_tline IS INITIAL.
    RETURN.
  ENDIF.

  LOOP AT gt_tline INTO gs_tline.
    CLEAR gs_display.
    MOVE-CORRESPONDING is_base TO gs_display.

    gs_display-row_kind = 'L'.
    gs_display-op_ltxt  = gs_tline-tdline.
    gs_display-tdformat = gs_tline-tdformat.

    APPEND gs_display TO gt_display.
  ENDLOOP.

ENDFORM.


*&---------------------------------------------------------------------*
*& Form append_char_longtext
*&---------------------------------------------------------------------*
*  - Appends characteristic long text lines as separate rows in GT_DISPLAY
*    with ROW_KIND = 'L' and CHAR_LTXT filled
*&---------------------------------------------------------------------*
FORM append_char_longtext USING is_base TYPE ty_task_base.

  DATA: ls_thead TYPE thead,
        lv_name  TYPE thead-tdname.

  CLEAR gt_tline.

  "Build text name for characteristic (adjust to match system)
  "Example: PLNTY + PLNNR (ALPHA) + PLNAL + MERKNR (ALPHA)
  lv_name = |{ is_base-plnty }{ is_base-plnnr ALPHA = OUT }{ is_base-plnal }{ is_base-merknr ALPHA = OUT }|.

  CLEAR ls_thead.
  ls_thead-tdid     = 'PLMK'.     "Characteristic long text ID (adjust if needed)
  ls_thead-tdspras  = sy-langu.
  ls_thead-tdname   = lv_name.
  ls_thead-tdobject = 'PLMK'.    "Characteristic text object (adjust if needed)

  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      id       = ls_thead-tdid
      language = ls_thead-tdspras
      name     = ls_thead-tdname
      object   = ls_thead-tdobject
    TABLES
      lines    = gt_tline
    EXCEPTIONS
      OTHERS   = 4.

  IF sy-subrc <> 0 OR gt_tline IS INITIAL.
    RETURN.
  ENDIF.

  LOOP AT gt_tline INTO gs_tline.
    CLEAR gs_display.
    MOVE-CORRESPONDING is_base TO gs_display.

    gs_display-row_kind  = 'L'.
    gs_display-char_ltxt = gs_tline-tdline.
    gs_display-tdformat  = gs_tline-tdformat.

    APPEND gs_display TO gt_display.
  ENDLOOP.

ENDFORM.


*======================================================================*
*   Toggle helpers for PF-STATUS buttons
*======================================================================*

*&---------------------------------------------------------------------*
*& Form toggle_char
*&---------------------------------------------------------------------*
FORM toggle_char.

  IF gv_show_char = gc_true.
    gv_show_char = gc_false.
  ELSE.
    gv_show_char = gc_true.
  ENDIF.

  PERFORM build_display.
  PERFORM set_pfstatus_from_state.
  PERFORM set_title_from_state.

  IF lo_alv IS BOUND.
    lo_alv->refresh( ).
  ENDIF.

ENDFORM.


*&---------------------------------------------------------------------*
*& Form toggle_ltxt
*&---------------------------------------------------------------------*
FORM toggle_ltxt.

  IF gv_show_ltxt = gc_true.
    gv_show_ltxt = gc_false.
  ELSE.
    gv_show_ltxt = gc_true.
  ENDIF.

  PERFORM build_display.
  PERFORM set_pfstatus_from_state.
  PERFORM set_title_from_state.

  IF lo_alv IS BOUND.
    lo_alv->refresh( ).
  ENDIF.

ENDFORM.
