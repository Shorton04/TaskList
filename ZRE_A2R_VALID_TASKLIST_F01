*&---------------------------------------------------------------------*
*& Include ZRE_A2R_VALID_TASKLIST_F01
*&---------------------------------------------------------------------*
*---------------------------------------------------------------------*
* EVENT HANDLER IMPLEMENTATION
*---------------------------------------------------------------------*
CLASS lcl_event_handler IMPLEMENTATION.
  METHOD on_user_command.

    CASE e_salv_function.

        "---------------------------------------------------------------
        " Show Characteristics
        " - Switch to operation + characteristics
        " - Long text goes back to default (off)
        "---------------------------------------------------------------
      WHEN gc_func_clist_s.     " &CLISTS
        gv_show_char = gc_true.
        gv_show_ltxt = gc_false.

        "---------------------------------------------------------------
        " Hide Characteristics
        " - Back to operations only
        " - Long text also reset (off)
        "---------------------------------------------------------------
      WHEN gc_func_clist_h.     " &CLISTH
        gv_show_char = gc_false.
        gv_show_ltxt = gc_false.

        "---------------------------------------------------------------
        " Show Long Text
        " - If gv_show_char = abap_false  → show operation long texts
        " - If gv_show_char = abap_true   → show characteristic long texts
        " (the distinction is handled inside BUILD_DISPLAY)
        "---------------------------------------------------------------
      WHEN gc_func_ltxt_s.      " &LTXTS
        gv_show_ltxt = gc_true.

        "---------------------------------------------------------------
        " Hide Long Text
        "---------------------------------------------------------------
      WHEN gc_func_ltxt_h.      " &LTXTH
        gv_show_ltxt = gc_false.

      WHEN OTHERS.
        RETURN.

    ENDCASE.

    " Rebuild data and refresh ALV / PF-STATUS / title
    PERFORM build_display.
    PERFORM set_pfstatus_from_state.
    PERFORM set_title_from_state.
    PERFORM set_column_visibility_by_state.

    IF lo_alv IS BOUND.
      lo_alv->refresh( ).
    ENDIF.

  ENDMETHOD.
ENDCLASS.

*---------------------------------------------------------------------*
* Validate Selection
*---------------------------------------------------------------------*
FORM validate_selection.

  IF p_ftl IS INITIAL AND
     p_etl IS INITIAL AND
     p_gtl IS INITIAL.
    MESSAGE e398(00) WITH 'Select at least one Task List Type'.
  ENDIF.

  IF so_keydt-low IS INITIAL.
    MESSAGE e398(00) WITH 'Enter a key date'.
  ENDIF.

ENDFORM.

*---------------------------------------------------------------------*
* PF-STATUS DETERMINATION
*---------------------------------------------------------------------*
FORM set_pfstatus_from_state.

  DATA lv_pf TYPE sypfkey.

  IF gv_show_char = gc_false AND gv_show_ltxt = gc_false.
    lv_pf = 'ZSALV_BOTH_HIDE'.
  ELSEIF gv_show_char = gc_false AND gv_show_ltxt = gc_true.
    lv_pf = 'ZSALV_LTXT_SHOW'.
  ELSEIF gv_show_char = gc_true AND gv_show_ltxt = gc_false.
    lv_pf = 'ZSALV_CLIST_ONLY'.
  ELSE.
    lv_pf = 'ZSALV_CLIST_LTXT'.
  ENDIF.

  IF lo_alv IS BOUND.
    lo_alv->set_screen_status(
      pfstatus = lv_pf
      report   = sy-repid ).
  ENDIF.

ENDFORM.

*---------------------------------------------------------------------*
* Title update
*---------------------------------------------------------------------*
FORM set_title_from_state.

  DATA lv_title TYPE string.
  lv_title = 'Maintenance Task List Report'.

  IF gv_show_char = gc_true.
    lv_title = lv_title && ' - Characteristics Active'.
  ENDIF.

  IF gv_show_ltxt = gc_true.
    lv_title = lv_title && ' - Long Text Active'.
  ENDIF.

  SET TITLEBAR 'TITLE_100' WITH lv_title.

ENDFORM.


*---------------------------------------------------------------------*
* Derive CI flags from PLMK-STEUERKZ
*---------------------------------------------------------------------*
FORM derive_ci_fields
  USING    iv_steuerkz TYPE plmk-steuerkz
  CHANGING cs_disp     TYPE ty_task_disp.

  DATA: lv_len TYPE i.

  lv_len = strlen( iv_steuerkz ).

  IF lv_len GE 1.  cs_disp-ci_quant         = iv_steuerkz+0(1).  ENDIF.
  IF lv_len GE 2.  cs_disp-ci_meas_required = iv_steuerkz+1(1).  ENDIF.
  IF lv_len GE 3.  cs_disp-ci_attr_ref      = iv_steuerkz+2(1).  ENDIF.
  IF lv_len GE 4.  cs_disp-ci_ulim_ind      = iv_steuerkz+3(1).  ENDIF.
  IF lv_len GE 5.  cs_disp-ci_llim_ind      = iv_steuerkz+4(1).  ENDIF.
  IF lv_len GE 6.  cs_disp-ci_chk_tgt       = iv_steuerkz+5(1).  ENDIF.
  IF lv_len GE 7.  cs_disp-ci_scope         = iv_steuerkz+6(1).  ENDIF.
  IF lv_len GE 8.  cs_disp-ci_single_res    = iv_steuerkz+7(1).  ENDIF.
  IF lv_len GE 9.  cs_disp-ci_samp_req      = iv_steuerkz+8(1).  ENDIF.
  IF lv_len GE 10. cs_disp-ci_recording     = iv_steuerkz+9(1).  ENDIF.
  IF lv_len GE 11. cs_disp-ci_doc_req       = iv_steuerkz+10(1). ENDIF.
  IF lv_len GE 12. cs_disp-ci_category      = iv_steuerkz+11(1). ENDIF.

ENDFORM.

*---------------------------------------------------------------------*
* GET_DATA
*---------------------------------------------------------------------*
FORM get_data.

  DATA: lv_keydat TYPE plko-datuv,
        lv_tolun  TYPE plmk-toleranzun,
        lv_tolob  TYPE plmk-toleranzob.

  CLEAR gt_base.
  CLEAR gs_base.

  " Key date (single value)
  lv_keydat = so_keydt-low.

  " Tolerance parameters (CHAR16 -> FLTP variables)
  CLEAR: lv_tolun, lv_tolob.
  IF so_tolun IS NOT INITIAL.
    lv_tolun = so_tolun.    " implicit conv CHAR16 -> FLTP
  ENDIF.
  IF so_tolob IS NOT INITIAL.
    lv_tolob = so_tolob.
  ENDIF.

  "-------------------------------------------------------------------*
  " Core selection: PLKO – PLAS – PLPO – PLMK – TAPL – EAPL – CRHD
  "-------------------------------------------------------------------*
  SELECT
    plko~plnty          " header
    plko~plnnr
    plko~plnal
    plko~datuv
    plko~werks
    plko~ktext
    plko~verwe
    plko~vagrp
    plko~statu     AS stat_h
    plko~anlzu     AS anlzu_h
    plko~strat
    plko~istru     AS istru_h
    plko~adpsp
    plko~slwbez
    plko~loekz     AS loekz_h
    plko~andat
    plko~annam
    plko~aedat
    plko~aenam

    tapl~tplnr      " FLOC assignment
    eapl~equnr      " EQUIP assignment

    plpo~plnkn
    plpo~zaehl
    plpo~vornr      " operation
    plpo~ltxa1
    plpo~steus
    crhd~arbpl      AS arbpl_o
    crhd~werks      AS werks_o
    plpo~ktsch
    plpo~arbei
    plpo~arbeh
    plpo~dauno
    plpo~daune
    plpo~kalid
    plpo~execution_stage
    plpo~anlzu      AS anlzu_o
    plpo~istru      AS istru_o
    plpo~larnt
    plpo~ebeln
    plpo~ebelp
    plpo~lifnr
    plpo~preis
    plpo~waers
    plpo~sakto
    plpo~ekorg
    plpo~ekgrp
    plpo~txtsp      AS txtsp_op
    plpo~loekz      AS loekz_o

    plmk~merknr     " characteristic
    plmk~verwmerkm
    plmk~kurztext   AS kurzt_char
    plmk~ltextkz
    plmk~toleranzun
    plmk~toleranzob
    plmk~pruefeinh
    plmk~stichprver
    plmk~pmethode
    plmk~katalgart1
    plmk~auswmenge1
    plmk~steuerkz
    plmk~loekz      AS loekz_c

    INTO CORRESPONDING FIELDS OF TABLE gt_base

    FROM  plko
      INNER JOIN plas
        ON  plas~plnty = plko~plnty
        AND plas~plnnr = plko~plnnr
        AND plas~plnal = plko~plnal
        AND plas~loekz = ' '
      INNER JOIN plpo
        ON  plpo~plnty = plas~plnty
        AND plpo~plnnr = plas~plnnr
        AND plpo~plnkn = plas~plnkn
        AND plpo~zaehl = plas~zaehl
        AND plpo~loekz = ' '
      LEFT OUTER JOIN plmk
        ON  plmk~plnty = plpo~plnty
        AND plmk~plnnr = plpo~plnnr
        AND plmk~plnkn = plpo~plnkn
        AND plmk~zaehl = plpo~zaehl
        AND plmk~loekz = ' '
      LEFT OUTER JOIN tapl
        ON  tapl~plnty = plko~plnty
        AND tapl~plnnr = plko~plnnr
        AND tapl~plnal = plko~plnal
        AND tapl~loekz = ' '
      LEFT OUTER JOIN eapl
        ON  eapl~plnty = plko~plnty
        AND eapl~plnnr = plko~plnnr
        AND eapl~plnal = plko~plnal
        AND eapl~loekz = ' '
      LEFT OUTER JOIN crhd
        ON  crhd~objid = plpo~arbid

    WHERE plko~loekz = ' '        " header not deleted
      AND plko~datuv <= lv_keydat.

  "-------------------------------------------------------------------*
  " Apply selection-screen filters in ABAP on GT_BASE
  "-------------------------------------------------------------------*
  DATA: lt_filtered TYPE STANDARD TABLE OF ty_task_base.

  CLEAR lt_filtered.

  LOOP AT gt_base INTO gs_base.

    "---- Task list type (PLKO-PLNTY) via checkboxes ------------------
    IF gs_base-plnty = 'A' AND p_ftl IS INITIAL.
      CONTINUE.
    ENDIF.
    IF gs_base-plnty = 'B' AND p_etl IS INITIAL.
      CONTINUE.
    ENDIF.
    IF gs_base-plnty = 'E' AND p_gtl IS INITIAL.
      CONTINUE.
    ENDIF.

    "---- Task list key: GROUP / COUNTER / PLANT ----------------------
    "GROUP  = PLKO-PLNNR  (your “Group” field)
    IF so_plnnr[] IS NOT INITIAL AND gs_base-plnnr NOT IN so_plnnr.
      CONTINUE.
    ENDIF.

    "COUNTER = PLKO-PLNAL  (if you have selection for counter)
    IF so_plnal[] IS NOT INITIAL AND gs_base-plnal NOT IN so_plnal.
      CONTINUE.
    ENDIF.

    "PLANT
    IF so_werks[] IS NOT INITIAL AND gs_base-werks NOT IN so_werks.
      CONTINUE.
    ENDIF.

    "---- Operation filters -------------------------------------------
    IF so_vornr[] IS NOT INITIAL AND gs_base-vornr NOT IN so_vornr.
      CONTINUE.
    ENDIF.

    IF so_otext[] IS NOT INITIAL AND gs_base-ltxa1 NOT IN so_otext.
      CONTINUE.
    ENDIF.

    "Operation long-text indicator (only ops that HAVE long text)
    IF p_oltin = 'X' AND gs_base-txtsp_op IS INITIAL.
      CONTINUE.
    ENDIF.

    "---- Characteristic filters --------------------------------------
    IF so_merkn[] IS NOT INITIAL AND gs_base-merknr NOT IN so_merkn.
      CONTINUE.
    ENDIF.

    IF so_mic[] IS NOT INITIAL AND gs_base-verwmerkm NOT IN so_mic.
      CONTINUE.
    ENDIF.

    IF so_cktxt[] IS NOT INITIAL AND gs_base-kurzt_char NOT IN so_cktxt.
      CONTINUE.
    ENDIF.

    IF so_ltxtk[] IS NOT INITIAL AND gs_base-ltextkz NOT IN so_ltxtk.
      CONTINUE.
    ENDIF.

    IF so_meth[] IS NOT INITIAL AND gs_base-pmethode NOT IN so_meth.
      CONTINUE.
    ENDIF.

    "Tolerance range
    IF so_tolun IS NOT INITIAL AND gs_base-toleranzun <> lv_tolun.
      CONTINUE.
    ENDIF.
    IF so_tolob IS NOT INITIAL AND gs_base-toleranzob <> lv_tolob.
      CONTINUE.
    ENDIF.

    "---- If we reach here: row matches ALL filled selections ---------

    APPEND gs_base TO lt_filtered.

  ENDLOOP.

  gt_base = lt_filtered.

ENDFORM.

*&---------------------------------------------------------------------*
*& Module STATUS_0100 OUTPUT
*&---------------------------------------------------------------------*
MODULE status_0100 OUTPUT.

  PERFORM set_pfstatus_from_state.
  PERFORM set_title_from_state.

  "Create container + SALV only once
  IF go_container IS INITIAL.

    CREATE OBJECT go_container
      EXPORTING
        container_name = 'CC_ALV'.   "Custom Control name on Screen 0100

    "Initial build of display table
    PERFORM build_display.

    "Create SALV inside container
    cl_salv_table=>factory(
      EXPORTING
        r_container  = go_container
      IMPORTING
        r_salv_table = lo_alv
      CHANGING
        t_table      = gt_display ).

    "Configure and display ALV in container
    PERFORM display_alv.

  ELSE.
    "Dataset might have changed between calls
    IF lo_alv IS BOUND.
      lo_alv->refresh( ).
    ENDIF.
  ENDIF.

ENDMODULE.

*======================================================================*
*   Helper Forms – PF-STATUS / Title
*======================================================================*

*======================================================================*
*   Core logic – Build display & Long text helpers
*======================================================================*

*&---------------------------------------------------------------------*
*& Form build_display
*&---------------------------------------------------------------------*
FORM build_display.

  DATA: lv_last_plnty TYPE plko-plnty,
        lv_last_plnnr TYPE plko-plnnr,
        lv_last_plnal TYPE plko-plnal,
        lv_last_vornr TYPE plpo-vornr.

  CLEAR gt_display.
  CLEAR gs_display.

  CLEAR: lv_last_plnty,
         lv_last_plnnr,
         lv_last_plnal,
         lv_last_vornr.

  " Make sure we loop in a stable key order
  SORT gt_base BY plnty plnnr plnal vornr merknr.

  LOOP AT gt_base INTO gs_base.

    "-----------------------------------------------------------*
    " 1) Operation row – only when operation key changes
    "-----------------------------------------------------------*
    IF     gs_base-plnty <> lv_last_plnty
       OR  gs_base-plnnr <> lv_last_plnnr
       OR  gs_base-plnal <> lv_last_plnal
       OR  gs_base-vornr <> lv_last_vornr.

      CLEAR gs_display.
      MOVE-CORRESPONDING gs_base TO gs_display.
      gs_display-row_kind = 'O'.              " Operation row

      PERFORM derive_ci_fields
        USING    gs_base-steuerkz
        CHANGING gs_display.

      APPEND gs_display TO gt_display.

      " Operation long text only when:
      "   - Long Text = ON
      "   - Show Characteristics = OFF (level = Operations per FDS)
      IF gv_show_ltxt = gc_true
         AND gv_show_char <> gc_true.
        PERFORM append_op_longtext USING gs_base.
      ENDIF.

      " Remember last operation key
      lv_last_plnty = gs_base-plnty.
      lv_last_plnnr = gs_base-plnnr.
      lv_last_plnal = gs_base-plnal.
      lv_last_vornr = gs_base-vornr.

    ENDIF.

    "-----------------------------------------------------------*
    " 2) Characteristic row + char long text (under operation)
    "-----------------------------------------------------------*
    IF gv_show_char = gc_true
       AND gs_base-merknr IS NOT INITIAL.

      " Characteristic “header” row
      CLEAR gs_display.
      MOVE-CORRESPONDING gs_base TO gs_display.
      gs_display-row_kind = 'C'.

      PERFORM derive_ci_fields
        USING    gs_base-steuerkz
        CHANGING gs_display.

      APPEND gs_display TO gt_display.

      " Characteristic long text only when:
      "   - Show Characteristics = ON
      "   - Long Text = ON (level = Characteristics per FDS)
      IF gv_show_ltxt = gc_true.
        PERFORM append_char_longtext USING gs_base.
      ENDIF.

    ENDIF.

  ENDLOOP.
  PERFORM adjust_display_fields_by_state.
ENDFORM.

FORM adjust_display_fields_by_state.

  FIELD-SYMBOLS: <ls_disp> TYPE ty_task_disp.

  LOOP AT gt_display ASSIGNING <ls_disp>.

    "-------------------------------------------------------------*
    " 1) Show Char = No, Show Long Text = No
    "    → Operations only, Insp# + Description blank on op rows
    "-------------------------------------------------------------*
    IF gv_show_char = gc_false AND gv_show_ltxt = gc_false.

      IF <ls_disp>-row_kind = 'O'.
        " Insp# + Description cleared, Method kept (per FDS)
        CLEAR: <ls_disp>-merknr,
               <ls_disp>-kurzt_char.
      ENDIF.

      "-------------------------------------------------------------*
      " 2) Show Char = No, Show Long Text = Yes
      "    → Operation rows + OP long texts, but
      "      Insp#, Description, Method must all be blank
      "-------------------------------------------------------------*
    ELSEIF gv_show_char = gc_false AND gv_show_ltxt = gc_true.

      IF <ls_disp>-row_kind = 'O'
      OR <ls_disp>-row_kind = 'L'.   "op long-text rows
        CLEAR: <ls_disp>-merknr,
               <ls_disp>-kurzt_char,
               <ls_disp>-pmethode.
      ENDIF.

      "-------------------------------------------------------------*
      " 3) Show Char = Yes, Show Long Text = No
      "    → Operation + characteristic rows, no long text
      "       (keep current values)
      "-------------------------------------------------------------*
    ELSEIF gv_show_char = gc_true AND gv_show_ltxt = gc_false.
      " No changes on data level

      "-------------------------------------------------------------*
      " 4) Show Char = Yes, Show Long Text = Yes
      "    → Operation + char rows + char long text
      "       (keep current values)
      "-------------------------------------------------------------*
    ELSE.
      " No changes

    ENDIF.

  ENDLOOP.

ENDFORM.

*---------------------------------------------------------------------*
* Display ALV – aligned to FDS column order & names
*---------------------------------------------------------------------*
FORM display_alv.

  DATA: lx_salv_ex  TYPE REF TO cx_root,
        lx_salv_msg TYPE REF TO cx_salv_msg.

  IF gt_display IS INITIAL.
    MESSAGE s398(00) WITH 'No data to display'.
    RETURN.
  ENDIF.

  TRY.

      " Create SALV only once
      IF lo_alv IS INITIAL.

        cl_salv_table=>factory(
          IMPORTING
            r_salv_table = lo_alv
          CHANGING
            t_table      = gt_display ).

        " Columns handling
        lo_columns = lo_alv->get_columns( ).
        lo_columns->set_optimize( abap_true ).

        "-----------------------------------------------------------*
        " Hide columns that are NOT in the FDS visible list
        "  Visible columns (do NOT hide):
        "    PLNNR, PLNAL, WERKS, VORNR,
        "    TDFORMAT, OP_LTXT (or TDLINE), ARBPL_O, ARBEI,
        "    KURZT_CHAR, PMETHODE, CHAR_LTXT
        "-----------------------------------------------------------*
        " Technical
        PERFORM hide_column USING 'ROW_KIND'.

        " Header to hide
        PERFORM hide_column USING 'PLNTY'.
        PERFORM hide_column USING 'DATUV'.
        PERFORM hide_column USING 'KTEXT'.
        PERFORM hide_column USING 'TPLNR'.
        PERFORM hide_column USING 'EQUNR'.
        PERFORM hide_column USING 'VERWE'.
        PERFORM hide_column USING 'VAGRP'.
        PERFORM hide_column USING 'STAT_H'.
        PERFORM hide_column USING 'ANLZU_H'.
        PERFORM hide_column USING 'STRAT'.
        PERFORM hide_column USING 'ISTRU_H'.
        PERFORM hide_column USING 'ADPSP'.
        PERFORM hide_column USING 'SLWBEZ'.
        PERFORM hide_column USING 'LOEKZ_H'.
        PERFORM hide_column USING 'ANDAT'.
        PERFORM hide_column USING 'ANNAM'.
        PERFORM hide_column USING 'AEDAT'.
        PERFORM hide_column USING 'AENAM'.

        " Operation to hide (keep VORNR, ARBPL_O, ARBEI)
        PERFORM hide_column USING 'LTXA1'.
        PERFORM hide_column USING 'STEUS'.
        PERFORM hide_column USING 'WERKS_O'.
        PERFORM hide_column USING 'KTSCH'.
        PERFORM hide_column USING 'ARBEH'.
        PERFORM hide_column USING 'DAUNO'.
        PERFORM hide_column USING 'DAUNE'.
        PERFORM hide_column USING 'KALID'.
        PERFORM hide_column USING 'EXECUTION_STAGE'.
        PERFORM hide_column USING 'ANLZU_O'.
        PERFORM hide_column USING 'ISTRU_O'.
        PERFORM hide_column USING 'LARNT'.
        PERFORM hide_column USING 'EBELN'.
        PERFORM hide_column USING 'EBELP'.
        PERFORM hide_column USING 'LIFNR'.
        PERFORM hide_column USING 'PREIS'.
        PERFORM hide_column USING 'WAERS'.
        PERFORM hide_column USING 'SAKTO'.
        PERFORM hide_column USING 'EKORG'.
        PERFORM hide_column USING 'EKGRP'.
        PERFORM hide_column USING 'TXTSP_OP'.
        PERFORM hide_column USING 'LOEKZ_O'.

        " Characteristic to hide (keep KURZT_CHAR, PMETHODE)
        PERFORM hide_column USING 'VERWMERKM'.
        PERFORM hide_column USING 'LTEXTKZ'.
        PERFORM hide_column USING 'TOLERANZUN'.
        PERFORM hide_column USING 'TOLERANZOB'.
        PERFORM hide_column USING 'PRUEFEINH'.
        PERFORM hide_column USING 'STICHPRVER'.
        PERFORM hide_column USING 'KATALGART1'.
        PERFORM hide_column USING 'AUSWMENGE1'.
        PERFORM hide_column USING 'STEUERKZ'.
        PERFORM hide_column USING 'LOEKZ_C'.

        " CI flags – all hidden
        PERFORM hide_column USING 'CI_QUANT'.
        PERFORM hide_column USING 'CI_MEAS_REQUIRED'.
        PERFORM hide_column USING 'CI_ATTR_REF'.
        PERFORM hide_column USING 'CI_ULIM_IND'.
        PERFORM hide_column USING 'CI_LLIM_IND'.
        PERFORM hide_column USING 'CI_CHK_TGT'.
        PERFORM hide_column USING 'CI_SCOPE'.
        PERFORM hide_column USING 'CI_SINGLE_RES'.
        PERFORM hide_column USING 'CI_SAMP_REQ'.
        PERFORM hide_column USING 'CI_RECORDING'.
        PERFORM hide_column USING 'CI_DOC_REQ'.
        PERFORM hide_column USING 'CI_CATEGORY'.

        " NOTE: Do NOT hide TDFORMAT, OP_LTXT, CHAR_LTXT, TDLINE.
        " If your structure still uses TDLINE instead of OP_LTXT/CHAR_LTXT,
        " the hide_column calls above will simply ignore non-existing fields.

        "-----------------------------------------------------------*
        " FDS column order (using columns->set_column_position)
        "  1  Group              (PLNNR)
        "  2  Counter            (PLNAL)
        "  3  Plant              (WERKS)
        "  4  Operation          (VORNR)
        "  5  Format Key         (TDFORMAT)
        "  6  Op Long Text       (OP_LTXT / TDLINE)
        "  7  Work Center        (ARBPL_O)
        "  8  Work               (ARBEI)
        "  9  Insp. Description  (KURZT_CHAR)
        " 10  Insp. Method       (PMETHODE)
        " 11  Char Long Text     (CHAR_LTXT)
        "-----------------------------------------------------------*
        PERFORM set_position USING 'PLNNR'      1.
        PERFORM set_position USING 'PLNAL'      2.
        PERFORM set_position USING 'WERKS'      3.
        PERFORM set_position USING 'VORNR'      4.
        PERFORM set_position USING 'TDFORMAT'   5.
        PERFORM set_position USING 'OP_LTXT'    6.
        PERFORM set_position USING 'ARBPL_O'    7.
        PERFORM set_position USING 'ARBEI'      8.
        PERFORM set_position USING 'MERKNR'     9.
        PERFORM set_position USING 'KURZT_CHAR'10.
        PERFORM set_position USING 'PMETHODE'  11.
        PERFORM set_position USING 'CHAR_LTXT' 12.

        "-----------------------------------------------------------*
        " Column texts – FDS-friendly captions
        "-----------------------------------------------------------*
        TRY.
            lo_column ?= lo_columns->get_column( 'PLNNR' ).
            lo_column->set_short_text(  |Grp| ).
            lo_column->set_medium_text( |Group| ).
            lo_column->set_long_text(   |Group| ).
          CATCH cx_salv_not_found.
        ENDTRY.

        TRY.
            lo_column ?= lo_columns->get_column( 'PLNAL' ).
            lo_column->set_short_text(  |Cntr| ).
            lo_column->set_medium_text( |Counter| ).
            lo_column->set_long_text(   |Counter| ).
          CATCH cx_salv_not_found.
        ENDTRY.

        TRY.
            lo_column ?= lo_columns->get_column( 'WERKS' ).
            lo_column->set_short_text(  |Plant| ).
            lo_column->set_medium_text( |Plant| ).
            lo_column->set_long_text(   |Plant| ).
          CATCH cx_salv_not_found.
        ENDTRY.

        TRY.
            lo_column ?= lo_columns->get_column( 'VORNR' ).
            lo_column->set_short_text(  |Op.| ).
            lo_column->set_medium_text( |Operation| ).
            lo_column->set_long_text(   |Operation| ).
          CATCH cx_salv_not_found.
        ENDTRY.

        TRY.
            lo_column ?= lo_columns->get_column( 'TDFORMAT' ).
            lo_column->set_short_text(  |FK| ).
            lo_column->set_medium_text( |Frmt Key| ).
            lo_column->set_long_text(   |Format Key| ).
          CATCH cx_salv_not_found.
        ENDTRY.

        TRY.
            lo_column ?= lo_columns->get_column( 'OP_LTXT' ).
            lo_column->set_short_text(  |Op Long Text| ).
            lo_column->set_medium_text( |Operation Long Text| ).
            lo_column->set_long_text(   |Operation Long Text| ).
          CATCH cx_salv_not_found.
        ENDTRY.

        TRY.
            lo_column ?= lo_columns->get_column( 'ARBPL_O' ).
            lo_column->set_short_text(  |Work Ctr| ).
            lo_column->set_medium_text( |Work Center| ).
            lo_column->set_long_text(   |Work Center| ).
          CATCH cx_salv_not_found.
        ENDTRY.

        TRY.
            lo_column ?= lo_columns->get_column( 'ARBEI' ).
            lo_column->set_short_text(  |Wrk| ).
            lo_column->set_medium_text( |Work| ).
            lo_column->set_long_text(   |Work| ).
          CATCH cx_salv_not_found.
        ENDTRY.

        TRY.
            lo_column ?= lo_columns->get_column( 'KURZT_CHAR' ).
            lo_column->set_short_text(  |Insp Desc| ).
            lo_column->set_medium_text( |Insp. Description| ).
            lo_column->set_long_text(   |Inspection Description| ).
          CATCH cx_salv_not_found.
        ENDTRY.

        TRY.
            lo_column ?= lo_columns->get_column( 'PMETHODE' ).
            lo_column->set_short_text(  |Insp Meth| ).
            lo_column->set_medium_text( |Inspection Method| ).
            lo_column->set_long_text(   |Inspection Method| ).
          CATCH cx_salv_not_found.
        ENDTRY.

        TRY.
            lo_column ?= lo_columns->get_column( |MERKNR| ).
            lo_column->set_short_text(  |Insp Meth| ).
            lo_column->set_medium_text( |Inspection Method| ).
            lo_column->set_long_text(   |Inspection Method| ).
          CATCH cx_salv_not_found.
        ENDTRY.

        TRY.
            lo_column ?= lo_columns->get_column( 'CHAR_LTXT' ).
            lo_column->set_short_text(  |Char Long Text| ).
            lo_column->set_medium_text( |Characteristic Long Text| ).
            lo_column->set_long_text(   |Characteristic Long Text| ).
          CATCH cx_salv_not_found.
        ENDTRY.

        " Display settings
        lo_disp = lo_alv->get_display_settings( ).
        lo_disp->set_striped_pattern( abap_true ).
        lo_disp->set_list_header( 'Valid Task Lists' ).

        " Layout
        lo_layout = lo_alv->get_layout( ).
        ls_layout_key-report = sy-repid.
        lo_layout->set_key( ls_layout_key ).
        lo_layout->set_default( abap_true ).

        " Functions
        lo_funcs = lo_alv->get_functions( ).
        lo_funcs->set_all( abap_true ).

        " Events
        lo_events = lo_alv->get_event( ).
        SET HANDLER lcl_event_handler=>on_user_command FOR lo_events.

      ELSE.
        " ALV already exists – just refresh data
        lo_alv->refresh( ).
      ENDIF.

      PERFORM set_column_visibility_by_state.
      PERFORM set_pfstatus_from_state.
      lo_alv->display( ).

    CATCH cx_salv_msg INTO lx_salv_msg.
      MESSAGE lx_salv_msg->get_text( ) TYPE 'E'.
    CATCH cx_root INTO lx_salv_ex.
      MESSAGE lx_salv_ex->get_text( ) TYPE 'E'.
  ENDTRY.

ENDFORM.

*&---------------------------------------------------------------------*
*& Form APPEND_OP_LONGTEXT
*&---------------------------------------------------------------------*
*  - Appends operation long text lines as separate rows in GT_DISPLAY
*    with:
*       ROW_KIND = 'L'
*       OP_LTXT  = text line
*    (other key fields copied from IS_BASE)
*&---------------------------------------------------------------------*
FORM append_op_longtext USING is_base TYPE ty_task_base.

  DATA: lt_lines TYPE STANDARD TABLE OF tline,
        ls_line  TYPE tline,
        lv_name  TYPE thead-tdname.

  CLEAR: lt_lines, lv_name.

  "Build TDNAME exactly as in standard examples:
  "  mandt + plnty + plnnr + plnkn + zaehl
  CONCATENATE sy-mandt
              is_base-plnty
              is_base-plnnr
              is_base-plnkn
              is_base-zaehl
         INTO lv_name.

  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      client   = sy-mandt
      id       = 'PLPO'
      language = sy-langu
      name     = lv_name
      object   = 'ROUTING'
    TABLES
      lines    = lt_lines
    EXCEPTIONS
      OTHERS   = 4.

  "No text → no extra rows
  IF sy-subrc <> 0 OR lt_lines IS INITIAL.
    RETURN.
  ENDIF.

  LOOP AT lt_lines INTO ls_line.

    CLEAR gs_display.
    MOVE-CORRESPONDING is_base TO gs_display.

    gs_display-row_kind = 'L'.               "long-text row
    gs_display-op_ltxt  = ls_line-tdline.    "text line
    gs_display-tdformat = ls_line-tdformat.  "format key (*, =, etc.)

    APPEND gs_display TO gt_display.

  ENDLOOP.

ENDFORM.


*&---------------------------------------------------------------------*
*& Form APPEND_CHAR_LONGTEXT
*&---------------------------------------------------------------------*
*  - Appends characteristic long text lines as separate rows in GT_DISPLAY
*    with:
*       ROW_KIND  = 'L'
*       CHAR_LTXT = text line
*&---------------------------------------------------------------------*
FORM append_char_longtext USING is_base TYPE ty_task_base.

  DATA: lt_lines TYPE STANDARD TABLE OF tline,
        ls_line  TYPE tline,
        lv_name  TYPE thead-tdname,
        lv_tmp   TYPE thead-tdname.

  CLEAR: lt_lines, lv_name, lv_tmp.

  " Only try to read if PLMK says: long text exists
  IF is_base-ltextkz IS INITIAL.
    RETURN.
  ENDIF.

  "-----------------------------------------------------------*
  " Build TDNAME for char long text:
  "   mandt + plnty + plnnr + plnkn + space + merknr + zaehl
  "   TDOBJECT = 'QSS', TDID = 'QM'
  "-----------------------------------------------------------*
  CONCATENATE sy-mandt
              is_base-plnty
              is_base-plnnr
              is_base-plnkn
         INTO lv_tmp.

  CONCATENATE lv_tmp
              is_base-merknr
         INTO lv_tmp
         SEPARATED BY space.

  CONCATENATE lv_tmp
              is_base-zaehl
         INTO lv_name.

  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      client                  = sy-mandt
      id                      = 'QM'
      language                = sy-langu
      name                    = lv_name
      object                  = 'QSS'
    TABLES
      lines                   = lt_lines
    EXCEPTIONS
      id                      = 1
      language                = 2
      name                    = 3
      not_found               = 4
      object                  = 5
      reference_check         = 6
      wrong_access_to_archive = 7
      OTHERS                  = 8.

  IF sy-subrc <> 0 OR lt_lines IS INITIAL.
    RETURN.
  ENDIF.

  LOOP AT lt_lines INTO ls_line.

    CLEAR gs_display.
    MOVE-CORRESPONDING is_base TO gs_display.

    gs_display-row_kind  = 'L'.
    gs_display-char_ltxt = ls_line-tdline.
    gs_display-tdformat  = ls_line-tdformat.

    " Make sure op long text column is empty on char rows
    CLEAR gs_display-op_ltxt.

    APPEND gs_display TO gt_display.

  ENDLOOP.

ENDFORM.


*======================================================================*
*   Toggle helpers for PF-STATUS buttons
*======================================================================*

*&---------------------------------------------------------------------*
*& Form toggle_char
*&---------------------------------------------------------------------*
FORM toggle_char.

  IF gv_show_char = gc_true.
    gv_show_char = gc_false.
  ELSE.
    gv_show_char = gc_true.
  ENDIF.

  PERFORM build_display.
  PERFORM set_pfstatus_from_state.
  PERFORM set_title_from_state.
  PERFORM set_column_visibility_by_state.

  IF lo_alv IS BOUND.
    lo_alv->refresh( ).
  ENDIF.

ENDFORM.

*&---------------------------------------------------------------------*
*& Form toggle_ltxt
*&---------------------------------------------------------------------*
FORM toggle_ltxt.

  IF gv_show_ltxt = gc_true.
    gv_show_ltxt = gc_false.
  ELSE.
    gv_show_ltxt = gc_true.
  ENDIF.

  PERFORM build_display.
  PERFORM set_pfstatus_from_state.
  PERFORM set_title_from_state.
  PERFORM set_column_visibility_by_state.

  IF lo_alv IS BOUND.
    lo_alv->refresh( ).
  ENDIF.

ENDFORM.


*---------------------------------------------------------------------*
* USER COMMAND (ONLY FOR BACK / EXIT / REFRESH)
*---------------------------------------------------------------------*
MODULE user_command_0100 INPUT.

  CASE sy-ucomm.

    WHEN 'REFRESH'.
      PERFORM build_display.
      PERFORM set_column_visibility_by_state.
      IF lo_alv IS BOUND.
        lo_alv->refresh( ).
      ENDIF.

    WHEN '&F03' OR '&F12' OR '&F15'.
      LEAVE TO SCREEN 0.

  ENDCASE.

ENDMODULE.

*---------------------------------------------------------------------*
* Helper: hide a column (technical)
*---------------------------------------------------------------------*
FORM hide_column USING pv_col TYPE lvc_fname.
  TRY.
      lo_column ?= lo_columns->get_column( pv_col ).
      lo_column->set_technical( abap_true ).
    CATCH cx_salv_not_found.
      " Ignore if column does not exist in current structure
  ENDTRY.
ENDFORM.

*---------------------------------------------------------------------*
* Helper: set column position (uses columns->set_column_position)
*---------------------------------------------------------------------*
FORM set_position USING pv_col TYPE lvc_fname
                        pv_pos TYPE i.

  TRY.
      lo_columns->set_column_position(
        columnname = pv_col
        position   = pv_pos ).
    CATCH cx_salv_not_found.
      " Ignore if column does not exist
  ENDTRY.

ENDFORM.

*---------------------------------------------------------------------*
* Helper: set column technical flag (visible / hidden)
*---------------------------------------------------------------------*
FORM set_column_technical USING pv_col  TYPE lvc_fname
                                pv_tech TYPE abap_bool.

  DATA: lo_col TYPE REF TO cl_salv_column_table.

  IF lo_alv IS INITIAL.
    RETURN.
  ENDIF.

  " Ensure we have the latest columns handle
  lo_columns = lo_alv->get_columns( ).

  TRY.
      lo_col ?= lo_columns->get_column( pv_col ).
      lo_col->set_technical( pv_tech ).
    CATCH cx_salv_not_found.
      " Ignore if column not in structure
  ENDTRY.

ENDFORM.


FORM set_column_visibility_by_state.

  IF lo_alv IS INITIAL.
    RETURN.
  ENDIF.

  " Start from all three visible
  PERFORM set_column_technical USING 'TDFORMAT' abap_false.
  PERFORM set_column_technical USING 'OP_LTXT'  abap_false.
  PERFORM set_column_technical USING 'CHAR_LTXT' abap_false.

  " Now apply the 4 combinations
  IF gv_show_char = gc_false AND gv_show_ltxt = gc_false.

    " A) No char, no long text
    PERFORM set_column_technical USING 'TDFORMAT' abap_true.
    PERFORM set_column_technical USING 'OP_LTXT'  abap_true.
    PERFORM set_column_technical USING 'CHAR_LTXT' abap_true.

  ELSEIF gv_show_char = gc_true AND gv_show_ltxt = gc_false.

    " B) Char only, no long text
    PERFORM set_column_technical USING 'TDFORMAT' abap_true.
    PERFORM set_column_technical USING 'OP_LTXT'  abap_true.
    PERFORM set_column_technical USING 'CHAR_LTXT' abap_true.

  ELSEIF gv_show_char = gc_false AND gv_show_ltxt = gc_true.

    " C) Op long text only
    "    → FK + OP_LTXT visible, CHAR_LTXT hidden
    PERFORM set_column_technical USING 'CHAR_LTXT' abap_true.

  ELSE.

    " D) Char + char long text
    "    → FK + CHAR_LTXT visible, OP_LTXT hidden
    PERFORM set_column_technical USING 'OP_LTXT' abap_true.

  ENDIF.

ENDFORM.
