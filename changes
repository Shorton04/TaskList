*&---------------------------------------------------------------------*
*& Form APPEND_OP_LONGTEXT
*&---------------------------------------------------------------------*
*  - Appends operation long text lines as separate rows in GT_DISPLAY
*    with:
*       ROW_KIND = 'L'
*       OP_LTXT  = text line
*       TDFORMAT = format key
*    (other key fields copied from IS_BASE)
*&---------------------------------------------------------------------*
FORM append_op_longtext USING is_base TYPE ty_task_base.

  DATA: lt_lines TYPE STANDARD TABLE OF tline,
        ls_line  TYPE tline,
        lv_name  TYPE thead-tdname.

  CLEAR: lt_lines, lv_name.

  "Build TDNAME exactly as in standard examples:
  "  mandt + plnty + plnnr + plnkn + zaehl
  CONCATENATE sy-mandt
              is_base-plnty
              is_base-plnnr
              is_base-plnkn
              is_base-zaehl
         INTO lv_name.

  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      client   = sy-mandt
      id       = 'PLPO'
      language = sy-langu
      name     = lv_name
      object   = 'ROUTING'
    TABLES
      lines    = lt_lines
    EXCEPTIONS
      OTHERS   = 4.

  "No text â†’ no extra rows
  IF sy-subrc <> 0 OR lt_lines IS INITIAL.
    RETURN.
  ENDIF.

  LOOP AT lt_lines INTO ls_line.

    CLEAR gs_display.
    MOVE-CORRESPONDING is_base TO gs_display.

    gs_display-row_kind = 'L'.               "long-text row
    gs_display-op_ltxt  = ls_line-tdline.    "text line
    gs_display-tdformat = ls_line-tdformat.  "format key (*, =, etc.)

    APPEND gs_display TO gt_display.

  ENDLOOP.

ENDFORM.





*&---------------------------------------------------------------------*
*& Form APPEND_CHAR_LONGTEXT
*&---------------------------------------------------------------------*
*  - Appends characteristic long text lines as separate rows in GT_DISPLAY
*    with:
*       ROW_KIND  = 'L'
*       CHAR_LTXT = text line
*       TDFORMAT  = format key
*&---------------------------------------------------------------------*
FORM append_char_longtext USING is_base TYPE ty_task_base.

  DATA: lt_lines TYPE STANDARD TABLE OF tline,
        ls_line  TYPE tline,
        lv_name  TYPE thead-tdname.

  CLEAR: lt_lines, lv_name.

  "Only bother if PLMK says long text exists
  IF is_base-ltextkz IS INITIAL.
    RETURN.
  ENDIF.

  "Build TDNAME per FDS for inspection characteristic long text:
  "  mandt + plnty + plnnr + plnkn + merknr
  CONCATENATE sy-mandt
              is_base-plnty
              is_base-plnnr
              is_base-plnkn
              is_base-merknr
         INTO lv_name.

  CALL FUNCTION 'READ_TEXT'
    EXPORTING
      client   = sy-mandt
      id       = 'QM'
      language = sy-langu
      name     = lv_name
      object   = 'QSS'
    TABLES
      lines    = lt_lines
    EXCEPTIONS
      OTHERS   = 4.

  IF sy-subrc <> 0 OR lt_lines IS INITIAL.
    RETURN.
  ENDIF.

  LOOP AT lt_lines INTO ls_line.

    CLEAR gs_display.
    MOVE-CORRESPONDING is_base TO gs_display.

    gs_display-row_kind  = 'L'.
    gs_display-char_ltxt = ls_line-tdline.
    gs_display-tdformat  = ls_line-tdformat.

    APPEND gs_display TO gt_display.

  ENDLOOP.

ENDFORM.